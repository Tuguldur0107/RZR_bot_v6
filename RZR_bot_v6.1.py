# üåê Built-in modules
import os
import json
import asyncio
import traceback
from datetime import datetime, timezone, timedelta

# üåø Third-party modules
import discord
from discord import app_commands, Embed
from discord.ext import commands
from dotenv import load_dotenv
import asyncpg
import openai
import traceback
from asyncio import sleep
from typing import List, Dict
import math

# üóÑÔ∏è Local modules
from database import (
    connect, pool, init_pool, ensure_pool,

    # üéØ Score & tier
    get_score, upsert_score, get_all_scores, get_default_tier,
    promote_tier, demote_tier, get_player_stats, update_player_stats,

    # üìä Match
    save_last_match, get_last_match, insert_match, clear_last_match,

    # üõ° Session
    save_session_state, load_session_state, clear_session_state,

    # üíñ Donator
    get_all_donators, upsert_donator,

    log_score_result,

    # üõ° Shields
    get_shields, upsert_shield
)

# üåê ENV
load_dotenv()
TOKEN = os.getenv("DISCORD_TOKEN")
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
if not OPENAI_API_KEY:
    raise ValueError("‚ùå OPENAI_API_KEY —Ç–æ—Ö–∏—Ä—É—É–ª–∞–≥–¥–∞–∞–≥“Ø–π –±–∞–π–Ω–∞.")
openai.api_key = OPENAI_API_KEY
GITHUB_TOKEN = os.getenv("GITHUB_TOKEN")
GITHUB_REPO = os.getenv("GITHUB_REPO")
GUILD_ID = int(os.getenv("GUILD_ID")) if os.getenv("GUILD_ID") else None

# üï∞ –¶–∞–≥–∏–π–Ω –±“Ø—Å
MN_TZ = timezone(timedelta(hours=8))

# üîß Discord intents
intents = discord.Intents.all()
bot = commands.Bot(command_prefix="/", intents=intents)

# ‚öôÔ∏è Tier config (1-1 ‚Üí 5-5)
TIER_ORDER = [
    "5-5", "5-4", "5-3", "5-2", "5-1",
    "4-5", "4-4", "4-3", "4-2", "4-1",
    "3-5", "3-4", "3-3", "3-2", "3-1",
    "2-5", "2-4", "2-3", "2-2", "2-1",
    "1-5", "1-4", "1-3", "1-2", "1-1"
]

TIER_WEIGHT = {
    "1-1": 120, "1-2": 115, "1-3": 110, "1-4": 105, "1-5": 100,
    "2-1":  95, "2-2":  90, "2-3":  85, "2-4":  80, "2-5":  75,
    "3-1":  70, "3-2":  65, "3-3":  60, "3-4":  55, "3-5":  50,
    "4-1":  45, "4-2":  40, "4-3":  35, "4-4":  30, "4-5":  25,
    "5-1":  20, "5-2":  15, "5-3":  10, "5-4":   5, "5-5":   0
}

def calculate_weight(data):
    tier = data.get("tier", "4-1")
    score = data.get("score", 0)
    tier_weight = TIER_WEIGHT.get(tier, 0)
    return max(tier_weight + score, 0)

load_dotenv()
DATABASE_URL = os.getenv("DATABASE_URL")

async def call_gpt_balance_api(team_count, players_per_team, players):
    import json
    from openai import OpenAI
    client = OpenAI()  # —ç—Å–≤—ç–ª —Ç–∞–Ω—ã –æ–¥–æ–æ —Ö—ç—Ä—ç–≥–ª—ç–∂ –±—É–π openai –æ–±—ä–µ–∫—Ç

    with open("prompts/balance_prompt.txt", "r", encoding="utf-8") as f:
        prompt_template = f.read()

    prompt = prompt_template.format(
        team_count=team_count,
        players_per_team=players_per_team,
        players=json.dumps(players, ensure_ascii=False)
    )

    try:
        # GPT-5 mini Balanced —Å–æ–Ω–≥–æ–ª—Ç: —Ö—É—Ä–¥ + “Ø–Ω—ç + —á–∞–Ω–∞—Ä –¥—É–Ω–¥–∞–∂ —Ç“Ø–≤—à–∏–Ω–¥.
        resp = await client.chat.completions.create(
            model="gpt-5-mini",
            messages=[
                {"role": "system", "content": "You are a precise team balancing engine that returns strict JSON only."},
                {"role": "user", "content": prompt},
            ],
            temperature=0.0,
            max_tokens=1024,
            seed=42,
            response_format={"type": "json_object"},
        )

        content = resp.choices[0].message.content.strip()

        # –ê—à–∏–≥–ª–∞—Ö JSON-–æ–æ —à—É—É–¥ parse
        parsed = json.loads(content)
        teams = parsed.get("teams", None)
        if not isinstance(teams, list):
            raise ValueError("`teams` not found or not a list in GPT response.")
        return teams

    except Exception as e:
        print("‚ùå GPT –±–∞–≥ —Ö—É–≤–∞–∞—Ä–∏–ª–∞–ª—Ç –∞–ª–¥–∞–∞:", e)
        raise

def team_totals(teams, weights):
    return [sum(weights.get(uid, 0) for uid in team) for team in teams]

def balance_cost(teams, weights):
    totals = team_totals(teams, weights)
    return max(totals) - min(totals)

def all_ids(teams):
    return [uid for team in teams for uid in team]

def local_refine(teams, weights, max_rounds=200):
    """
    –ñ–∏–∂–∏–≥—Ö—ç–Ω greedy swap heuristic:
    - –ë–∞–≥—É—É–¥—ã–Ω –∞–ª—å —Ö–∞–º–≥–∏–π–Ω –∏—Ö/–±–∞–≥–∞ –Ω–∏–π–ª–±—ç—Ä—Ç—ç–π–≥ –æ–ª–Ω–æ
    - –¢—ç—Ä 2 –±–∞–≥–∏–π–Ω –≥–∏—à“Ø“Ø–¥—ç—ç—Å —Å–æ–ª–∏–ª—Ü–æ—Ö —Ö–æ—Å —Ö–∞–π–Ω–∞ (–∑–∞—Ä–¥–ª—ã–≥ –±–∞–≥–∞—Å–≥–∞–≤–∞–ª —à—É—É–¥ —Ö—ç—Ä—ç–≥–∂“Ø“Ø–ª–Ω—ç)
    - –î–∞–≤—Ç–∞–Ω–∞ (max_rounds)
    """
    from copy import deepcopy
    T = deepcopy(teams)
    def score(tt): return balance_cost(tt, weights)

    best = score(T)
    rounds = 0

    while rounds < max_rounds:
        rounds += 1
        totals = team_totals(T, weights)
        hi = max(range(len(T)), key=lambda i: totals[i])
        lo = min(range(len(T)), key=lambda i: totals[i])

        improved = False
        # hi –±–∞ lo –±–∞–≥–∏–π–Ω —Ö–æ–æ—Ä–æ–Ω–¥ swap —Ö–∞–π–Ω–∞
        for a_idx, a in enumerate(T[hi]):
            for b_idx, b in enumerate(T[lo]):
                if a == b: 
                    continue
                cand = [list(x) for x in T]
                cand[hi][a_idx], cand[lo][b_idx] = cand[lo][b_idx], cand[hi][a_idx]
                c = score(cand)
                if c < best:
                    T = cand
                    best = c
                    improved = True
                    break
            if improved:
                break

        if not improved:
            break
    return T, best

def tier_score(data: dict) -> int:
    tier = data.get("tier", "4-1")
    score = data.get("score", 0)
    return TIER_WEIGHT.get(tier, 0) + score

def promote_tier(tier):  # –°–∞–π–∂—Ä–∞—Ö ‚Üí index -1
    try:
        i = TIER_ORDER.index(tier)
        return TIER_ORDER[max(i + 1, 0)]
    except:
        return tier

def demote_tier(tier):  # –î–æ—Ä–¥–æ—Ö ‚Üí index +1
    try:
        i = TIER_ORDER.index(tier)
        return TIER_ORDER[min(i - 1, len(TIER_ORDER) - 1)]
    except:
        return tier

def generate_tier_order():
    return [f"{i}-{j}" for i in range(5, 0, -1) for j in range(5, 0, -1)]

def get_default_tier():
    return {"score": 0, "tier": "4-1"}

def snake_teams(player_weights, team_count, players_per_team):
    sorted_players = sorted(player_weights.items(), key=lambda x: x[1], reverse=True)
    teams = [[] for _ in range(team_count)]

    forward = True
    team_index = 0
    for uid, _ in sorted_players:
        teams[team_index].append(uid)

        if forward:
            team_index += 1
            if team_index == team_count:
                team_index -= 1
                forward = False
        else:
            team_index -= 1
            if team_index < 0:
                team_index = 0
                forward = True

    return teams

def greedy_teams(player_weights, team_count, players_per_team):
    sorted_players = sorted(player_weights.items(), key=lambda x: x[1], reverse=True)
    teams = [[] for _ in range(team_count)]
    team_totals = [0] * team_count

    for uid, weight in sorted_players:
        # ‚úÖ —Ö“Ø–Ω –±“Ø—Ä –±–∞–≥—Ç–∞–∞ –¥—ç—ç–¥ —Ç–∞–ª –Ω—å players_per_team —Ö“Ø—Ä–≥—ç–∂ –∞–≤–Ω–∞
        valid_indexes = [
            i for i in range(team_count)
            if len(teams[i]) < players_per_team
        ]

        if not valid_indexes:
            break  # –±“Ø—Ö –±–∞–≥ –¥“Ø“Ø—Ä—Å—ç–Ω –±–æ–ª –∑–æ–≥—Å–æ–Ω–æ

        min_team_index = min(valid_indexes, key=lambda i: team_totals[i])
        teams[min_team_index].append(uid)
        team_totals[min_team_index] += weight

    return teams

def reflector_teams(player_weights: dict, team_count: int, players_per_team: int):
    sorted_players = sorted(player_weights.items(), key=lambda x: x[1], reverse=True)
    teams = [[] for _ in range(team_count)]

    left = 0
    right = len(sorted_players) - 1
    i = 0

    while left <= right:
        if len(teams[i]) < players_per_team:
            teams[i].append(sorted_players[left][0])
            left += 1
        if left <= right and len(teams[i]) < players_per_team:
            teams[i].append(sorted_players[right][0])
            right -= 1
        i = (i + 1) % team_count

    return teams

def total_weight_difference(teams, player_weights):
    team_totals = [sum(player_weights.get(uid, 0) for uid in team) for team in teams]
    return max(team_totals) - min(team_totals)

def get_donator_emoji(data):
    from datetime import datetime, timezone, timedelta

    total = data.get("total_mnt", 0)
    last_donated = data.get("last_donated")

    if not last_donated:
        return ""

    try:
        donated_time = last_donated if isinstance(last_donated, datetime) else datetime.fromisoformat(str(last_donated))
        if donated_time.tzinfo is None:
            donated_time = donated_time.replace(tzinfo=timezone.utc)
    except Exception as e:
        print("‚ùå Emoji parse fail:", e)
        return ""

    now = datetime.now(timezone.utc)
    if (now - donated_time).days > 30:
        return ""

    if total >= 30000:
        return "üëë"
    elif total >= 10000:
        return "üí∏"
    else:
        return "üí∞"

def clean_nickname(nick: str) -> str:
    """
    {donor} {tier} | {base} | {perf}  ‚Üí base
    {tier} | {base}                    ‚Üí base
    other                              ‚Üí trimmed(nick)
    """
    if not nick:
        return ""
    parts = [p.strip() for p in nick.split(" | ")]
    if len(parts) >= 2:
        # len==3 (donor/tier | base | perf)  —ç—Å–≤—ç–ª len==2 (tier | base)
        return parts[1]
    return nick.strip()

async def update_nicknames_for_users(guild, user_ids: list[int]):
    from database import get_all_donators, get_score
    donors = await get_all_donators()

    MAX_LEN = 32
    for uid in user_ids:
        member = guild.get_member(uid)
        if not member:
            continue
        if member.top_role >= guild.me.top_role:
            continue

        data = await get_score(uid)
        if not data:
            continue

        tier = data.get("tier", "4-1")
        base = clean_nickname(member.display_name)

        donor_emoji = ""
        d = donors.get(str(uid))
        if d:
            donor_emoji = get_donator_emoji(d) or ""

        perf = await get_performance_emoji(uid)  # "‚úÖ‚úÖ", "‚ùå", "‚è∏", "‚ûñ" –≥.–º.

        # "{donor} {tier} | {base} | {perf}"  (perf —Ö–æ–æ—Å–æ–Ω/‚è∏/‚ûñ –±–∞–π—Å–∞–Ω —á —Ö–∞—Ä–∞–≥–¥–∞–Ω–∞)
        prefix = f"{donor_emoji} {tier}".strip()
        parts = [prefix, base] + ([perf] if perf else [])
        new_nick = " | ".join(parts)

        if len(new_nick) > MAX_LEN:
            fixed_len = len(prefix) + 3 + (3 + len(perf) if perf else 0)  # prefix + " | " + (" | perf")
            allow = max(MAX_LEN - fixed_len, 0)
            base = base[:allow]
            parts = [prefix, base] + ([perf] if perf else [])
            new_nick = " | ".join(parts)

        try:
            if member.nick != new_nick:
                await member.edit(nick=new_nick)
                print(f"‚úÖ nickname ‚Üí {uid}: {new_nick}")
            else:
                print(f"‚ÜîÔ∏è {uid}: unchanged ‚Üí –∞–ª–≥–∞—Å–∞–≤ ({new_nick})")
        except Exception as e:
            print(f"‚ö†Ô∏è Nickname update –∞–ª–¥–∞–∞: {uid} ‚Äî {e}")

async def ensure_pool() -> bool:
    try:
        if pool is None:
            print("‚ÑπÔ∏è ensure_pool: initializing pool‚Ä¶")
            await init_pool()  # database.py
        return True
    except Exception as e:
        print(f"‚ö†Ô∏è ensure_pool error: {e}")
        return False
    
PERF_EMOJI_CAP = None  # None = —Ö—è–∑–≥–∞–∞—Ä–≥“Ø–π; –∂–∏—à—ç—ç –Ω—å 5 –±–æ–ª 5 —Ö“Ø—Ä—Ç—ç–ª

async def get_performance_emoji(uid: int) -> str:
    SQL = """
        SELECT result
        FROM score_log
        WHERE uid = $1
          AND timestamp >= (NOW() AT TIME ZONE 'UTC') - INTERVAL '12 HOURS'
    """
    rows, conn = [], None
    try:
        from database import ensure_pool as _ensure, pool as _pool, connect as _connect
        ok = await _ensure()
        if ok and _pool is not None:
            async with _pool.acquire() as c:
                rows = await c.fetch(SQL, uid)
        else:
            conn = await _connect()
            rows = await conn.fetch(SQL, uid)
    except Exception as e:
        print(f"‚ö†Ô∏è get_performance_emoji –∞–ª–¥–∞–∞: {uid} ‚Äî {e}")
        return ""
    finally:
        if conn:
            try:
                await conn.close()
            except:
                pass

    if not rows:
        return "‚è∏"  # —Å“Ø“Ø–ª–∏–π–Ω 12 —Ü–∞–≥—Ç —Ç–æ–≥–ª–æ–æ–≥“Ø–π (—è–ª–≥–∞–∞—Ç–∞–π —Ç—ç–º–¥—ç–≥)

    perf = sum(1 if r["result"] == "win" else -1 for r in rows)

    if perf > 0:
        n = perf if PERF_EMOJI_CAP is None else min(perf, PERF_EMOJI_CAP)
        return "‚úÖ" * n
    if perf < 0:
        n = (-perf) if PERF_EMOJI_CAP is None else min(-perf, PERF_EMOJI_CAP)
        return "‚ùå" * n
    return "‚ûñ"  # —è–ª–∞–ª—Ç/—è–ª–∞–≥–¥–∞–ª —Ç—ç–Ω—Ü“Ø“Ø

async def ensure_scores_for_users(guild, uids: list[int]) -> list[int]:
    """scores —Ö“Ø—Å–Ω—ç–≥—Ç—ç–¥ –±–∞–π—Ö–≥“Ø–π –±–æ–ª default tier/score-–æ–æ—Ä “Ø“Ø—Å–≥—ç–Ω—ç."""
    created = []
    for uid in uids:
        try:
            if not await get_score(uid):
                member = guild.get_member(uid)
                username = member.display_name if member else "Unknown"
                d = get_default_tier()  # {"score":0,"tier":"4-1"}
                await upsert_score(uid, d["score"], d["tier"], username)
                created.append(uid)
        except Exception as e:
            print(f"‚ö†Ô∏è ensure_scores_for_users –∞–ª–¥–∞–∞ uid={uid}: {e}")
    if created:
        print(f"üÜï scores-–¥ —à–∏–Ω—ç—ç—Ä –Ω—ç–º—ç–≥–¥—Å—ç–Ω: {created}")
    return created

# ‚è± 24h session timeout
async def session_timeout_checker():
    await bot.wait_until_ready()
    while not bot.is_closed():
        await asyncio.sleep(3600)

        session = await load_session_state()
        if not session:
            continue

        if session.get("active"):
            last_win_time_str = session.get("last_win_time")
            if not last_win_time_str:
                continue

            try:
                last_win_time = datetime.fromisoformat(last_win_time_str)
                if last_win_time.tzinfo is None:
                    last_win_time = last_win_time.replace(tzinfo=timezone.utc)  # ‚úÖ FIX

                now = datetime.now(timezone.utc)
                if (now - last_win_time).total_seconds() > 86400:
                    await clear_session_state()
                    print("üîö Session –∞–≤—Ç–æ–º–∞—Ç–∞–∞—Ä —Ö–∞–∞–≥–¥–ª–∞–∞ (24h).")
            except Exception as e:
                print("‚ö†Ô∏è session_timeout_checker parse –∞–ª–¥–∞–∞:", e)

def _tier_arrow(old_tier: str, new_tier: str) -> str:
    try:
        oi = TIER_ORDER.index(old_tier); ni = TIER_ORDER.index(new_tier)
        if ni < oi:  return "‚¨Ü"
        if ni > oi:  return "‚¨á"
        return "‚Üí"
    except Exception:
        return ""

async def _fmt_player_line(guild, weights_map, p: Dict) -> str:
    """
    p: {"uid", "username", "old_score","new_score","old_tier","new_tier","team"}
    """
    uid = p["uid"]
    member = guild.get_member(uid)
    name = member.display_name if member else p.get("username") or str(uid)
    old_s, new_s = p.get("old_score", 0), p.get("new_score", 0)
    old_t, new_t = p.get("old_tier", "4-1"), p.get("new_tier", "4-1")
    arrow = _tier_arrow(old_t, new_t)
    perf  = await get_performance_emoji(uid)  # ‚úÖ / ‚ùå / ‚è∏ / ‚ûñ
    w     = weights_map.get(uid)  # –±–∞–π—Ö–≥“Ø–π –±–∞–π–∂ –±–æ–ª–Ω–æ
    w_txt = f" ¬∑ w:{w}" if w is not None else ""
    return f"- <@{uid}> **{name}** ‚Äî `{old_s} ‚Üí {new_s}` ¬∑ `[{old_t} ‚Üí {new_t}]` {arrow} {perf}{w_txt}"

def _chunks(lst, n):
    for i in range(0, len(lst), n):
        yield lst[i:i+n]

async def send_match_result_embed(
    interaction: discord.Interaction,
    *,
    mode_label: str,               # "Normal" | "Fountain"
    ranked: bool,
    win_indexes: List[int],
    lose_indexes: List[int],
    winner_details: List[Dict],
    loser_details: List[Dict],
    session: Dict,
    weights_map: Dict[int, int] | None = None
):
    guild = interaction.guild
    weights_map = weights_map or {}

    # ‚îÄ Summary ‚îÄ
    win_str  = ", ".join(f"{i+1}-—Ä –±–∞–≥" for i in win_indexes) if win_indexes else "‚Äî"
    lose_str = ", ".join(f"{i+1}-—Ä –±–∞–≥" for i in lose_indexes) if lose_indexes else "‚Äî"
    ranked_badge = "üèÖ Ranked" if ranked else "‚ö†Ô∏è Unranked"
    title = f"üèÜ Match Result ‚Äî {mode_label} ({ranked_badge})"

    emb = discord.Embed(
        title=title,
        description=f"**Winners:** {win_str}\n**Losers:** {lose_str}",
        color=0x43B581 if ranked else 0x7289DA
    )

    # ‚îÄ Winners field(s) ‚îÄ
    if winner_details:
        lines_w = []
        for p in winner_details:
            try:
                line = await _fmt_player_line(guild, weights_map, p)
                lines_w.append(line)
            except Exception as e:
                print("winner line error:", e)
        # Discord embed field limit ~1024 —Ç—ç–º–¥—ç–≥—Ç ‚Üí —Ö—ç—Å—ç–≥–ª—ç–∂ –Ω—ç–º–Ω—ç
        for part in _chunks(lines_w, 10):
            emb.add_field(name="‚úÖ Winners", value="\n".join(part), inline=False)
    else:
        emb.add_field(name="‚úÖ Winners", value="‚Äî", inline=False)

    # ‚îÄ Losers field(s) ‚îÄ
    if loser_details:
        lines_l = []
        for p in loser_details:
            try:
                line = await _fmt_player_line(guild, weights_map, p)
                lines_l.append(line)
            except Exception as e:
                print("loser line error:", e)
        for part in _chunks(lines_l, 10):
            emb.add_field(name="üíÄ Losers", value="\n".join(part), inline=False)
    else:
        emb.add_field(name="üíÄ Losers", value="‚Äî", inline=False)

    # ‚îÄ Footer ‚îÄ
    initiator = session.get("initiator_id")
    team_cnt  = session.get("team_count") or len(session.get("teams") or [])
    ppl_team  = session.get("players_per_team") or (max(len(t) for t in session.get("teams") or [[]]) if session.get("teams") else 0)
    emb.set_footer(text=f"Teams: {team_cnt} √ó {ppl_team} ‚Ä¢ Initiator: {initiator}")

    # –ò–ª–≥—ç—ç—Ö
    await interaction.followup.send(embed=emb)

# ‚îÄ‚îÄ Team assignment Embed helper ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
from typing import Dict, List

def _team_badge(i: int) -> str:
    badges = ["ü•á","ü•à","ü•â","üéØ","üî•","üöÄ","üéÆ","üõ°Ô∏è","‚öîÔ∏è","üß†","üèÖ"]
    return badges[i % len(badges)]

async def _fmt_member_line(guild, uid: int, w: int | None, is_leader: bool) -> str:
    member = guild.get_member(uid)
    name = member.display_name if member else str(uid)
    perf = await get_performance_emoji(uid)  # ‚úÖ/‚ùå/‚è∏/‚ûñ
    leader = " üòé Team Leader" if is_leader else ""
    wtxt = f" ({w})" if w is not None else ""
    return f"- {name}{wtxt} {perf}{leader}"

def _split_fields(lines: List[str], per_field: int = 10) -> List[str]:
    return ["\n".join(lines[i:i+per_field]) for i in range(0, len(lines), per_field)]

async def send_team_assignment_embed(
    interaction: discord.Interaction,
    *,
    title_prefix: str,            # "Bot" | "GPT"
    strategy_note: str,           # –∂: "`snake` (diff=12)" —ç—Å–≤—ç–ª "`gpt+local_refine` (diff=7)"
    team_count: int,
    players_per_team: int,
    teams: List[List[int]],
    weights_map: Dict[int, int],
    left_out: List[int] | List[tuple] | None = None,
    ranked: bool | None = None
):
    guild = interaction.guild
    left_out = left_out or []
    # total & diff
    totals = [sum(weights_map.get(u, 0) for u in team) for team in teams]
    diff = (max(totals) - min(totals)) if totals else 0

    ranked_badge = ""
    if ranked is not None:
        ranked_badge = " ‚Ä¢ üèÖ Ranked" if ranked else " ‚Ä¢ ‚ö†Ô∏è Unranked"

    emb = discord.Embed(
        title=f"ü§ù {title_prefix} ‚Äî Team Assignment",
        description=f"Strategy: {strategy_note} ‚Ä¢ diff: `{diff}`{ranked_badge}\n"
                    f"Setup: **{team_count} √ó {players_per_team}**",
        color=0x2ECC71 if title_prefix.lower() == "bot" else 0x5865F2
    )

    # Teams
    for i, team in enumerate(teams):
        badge = _team_badge(i)
        t_total = totals[i] if i < len(totals) else 0
        # team leader (highest weight)
        leader_uid = max(team, key=lambda u: weights_map.get(u, 0)) if team else None

        # member lines
        member_lines = []
        for u in team:
            w = weights_map.get(u)
            member_lines.append(await _fmt_member_line(guild, u, w, is_leader=(u == leader_uid)))

        # split to multiple fields if long
        parts = _split_fields(member_lines, per_field=10)
        # first field shows team header
        if parts:
            emb.add_field(
                name=f"{badge} Team #{i+1} ‚Äî total: `{t_total}`",
                value=parts[0],
                inline=False
            )
            for extra in parts[1:]:
                emb.add_field(name="\u200B", value=extra, inline=False)  # zero-width header
        else:
            emb.add_field(
                name=f"{badge} Team #{i+1} ‚Äî total: `{t_total}`",
                value="‚Äî",
                inline=False
            )

    # Left‚Äëout players (if any)
    lo_ids = []
    if left_out:
        # left_out may be list[(uid, weight)] —ç—Å–≤—ç–ª list[uid]
        for x in left_out:
            if isinstance(x, tuple) or isinstance(x, list):
                lo_ids.append(int(x[0]))
            else:
                lo_ids.append(int(x))
        lo_text = "‚Ä¢ " + "\n‚Ä¢ ".join(f"<@{u}>" for u in lo_ids)
        emb.add_field(name="‚ö†Ô∏è This round not included", value=lo_text, inline=False)

    await interaction.followup.send(embed=emb)


# üß¨ Start
@bot.event
async def on_ready():
    print(f"ü§ñ Bot –Ω—ç–≤—Ç—ç—Ä–ª—ç—ç: {bot.user}")
    print("üìÅ Working directory:", os.getcwd())
    await init_pool() 
    print("‚úÖ DB pool –∞–º–∂–∏–ª—Ç—Ç–∞–π —ç—Ö—ç–ª–ª—ç—ç.")
    # ‚öôÔ∏è Slash –∫–æ–º–∞–Ω–¥—É—É–¥—ã–≥ global sync —Ö–∏–π–Ω—ç
    await bot.tree.sync()

    # üß† Async task-–∞–∞—Ä session –±–æ–ª–æ–Ω DB pool initialize —Ö–∏–π–Ω—ç
    asyncio.create_task(initialize_bot())

    # üïì Timeout —à–∞–ª–≥–∞–≥—á–∏–π–≥ —ç—Ö–ª“Ø“Ø–ª–Ω—ç
    asyncio.create_task(session_timeout_checker())

async def initialize_bot():
    try:
        await init_pool()
        print("‚úÖ DB pool initialized.")
    except Exception as e:
        print("‚ùå DB pool initialization –∞–ª–¥–∞–∞:", e)

    try:
        await load_session_state()
        print("üì• Session state –∞–º–∂–∏–ª—Ç—Ç–∞–π –∞—á–∞–∞–ª–∞–≥–¥–ª–∞–∞.")
    except Exception as e:
        print("‚ùå Session –∞—á–∞–∞–ª–∞—Ö “Ø–µ–¥ –∞–ª–¥–∞–∞ –≥–∞—Ä–ª–∞–∞:", e)

# üß© Command: ping
@bot.tree.command(name="ping", description="Bot-–∏–π–Ω latency-–≥ —à–∞–ª–≥–∞–Ω–∞")
async def ping(interaction: discord.Interaction):
    await interaction.response.send_message("üèì Pong!")

@bot.tree.command(name="start_match", description="Session —ç—Ö–ª“Ø“Ø–ª–Ω—ç (—à–∏–Ω—ç —Ç–æ–≥–ª–æ–ª—Ç—ã–Ω session)")
async def start_match(interaction: discord.Interaction):
    try:
        await interaction.response.defer(thinking=True)
    except discord.errors.InteractionResponded:
        return
    try:
        await clear_session_state()
        print("üßº ”©–º–Ω”©—Ö session_state —É—Å—Ç–ª–∞–∞.")
    except Exception as e:
        print("‚ùå clear_session_state –∞–ª–¥–∞–∞:", e)

    try:
        now = datetime.now(timezone.utc)

        await save_session_state({
            "active": True,
            "start_time": now,
            "last_win_time": now,
            "initiator_id": interaction.user.id,
            "player_ids": [],
            "teams": [],
            "changed_players": [],
            "strategy": ""
        }, allow_empty=True)

        await interaction.followup.send(
            "üü¢ Session —ç—Ö—ç–ª–ª—ç—ç. `addme` –∫–æ–º–º–∞–Ω–¥–∞–∞—Ä —Ç–æ–≥–ª–æ–≥—á–∏–¥ –±“Ø—Ä—Ç–≥“Ø“Ø–ª–Ω—ç “Ø“Ø."
        )

    except Exception as e:
        print("‚ùå start_match –±“Ø—Ö—ç–ª–¥—ç—ç –≥–∞—Ü–ª–∞–∞:", e)
        if not interaction.response.is_done():
            await interaction.followup.send("‚ö†Ô∏è Session —ç—Ö–ª“Ø“Ø–ª—ç—Ö—ç–¥ –∞–ª–¥–∞–∞ –≥–∞—Ä–ª–∞–∞.", ephemeral=True)

@bot.tree.command(name="addme", description="–¢–æ–≥–ª–æ–≥—á ”©”©—Ä–∏–π–≥”©”© –±“Ø—Ä—Ç–≥“Ø“Ø–ª–Ω—ç")
async def addme(interaction: discord.Interaction):
    try:
        await interaction.response.defer(thinking=True)
    except discord.errors.InteractionResponded:
        return

    try:
        user_id = interaction.user.id
        session = await load_session_state()
        if not session or not session.get("active"):
            await interaction.followup.send("‚ö†Ô∏è –û–¥–æ–æ–≥–æ–æ—Ä session —ç—Ö–ª—ç—ç–≥“Ø–π –±–∞–π–Ω–∞.")
            return

        player_ids = session.get("player_ids", [])
        if user_id in player_ids:
            await interaction.followup.send("üìå –¢–∞ –∞–ª—å —Ö—ç–¥–∏–π–Ω –±“Ø—Ä—Ç–≥“Ø“Ø–ª—Å—ç–Ω –±–∞–π–Ω–∞.")
            return

        player_ids.append(user_id)
        session["player_ids"] = player_ids
        # üß† datetime —Ö”©—Ä–≤“Ø“Ø–ª—ç–ª—Ç —Ö–∏–π–∂ ”©–≥–Ω”©
        if isinstance(session.get("start_time"), str):
            session["start_time"] = datetime.fromisoformat(session["start_time"])
        if isinstance(session.get("last_win_time"), str):
            session["last_win_time"] = datetime.fromisoformat(session["last_win_time"])

        await save_session_state(session)
        await interaction.followup.send(
            f"‚úÖ {interaction.user.mention} –±“Ø—Ä—Ç–≥“Ø“Ø–ª–ª—ç—ç.\n–ù–∏–π—Ç –±“Ø—Ä—Ç–≥—ç–≥–¥—Å—ç–Ω: {len(player_ids)}"
        )

    except Exception as e:
        print("‚ùå addme –±“Ø—Ö—ç–ª–¥—ç—ç –∞–ª–¥–∞–∞:", e)
        await interaction.followup.send("‚ö†Ô∏è –ë“Ø—Ä—Ç–≥—ç—Ö “Ø–µ–¥ –∞–ª–¥–∞–∞ –≥–∞—Ä–ª–∞–∞.")

@bot.tree.command(name="show_added_players", description="–ë“Ø—Ä—Ç–≥—ç–≥–¥—Å—ç–Ω —Ç–æ–≥–ª–æ–≥—á–¥—ã–≥ —Ö–∞—Ä—É—É–ª–Ω–∞")
async def show_added_players(interaction: discord.Interaction):
    try:
        await interaction.response.defer(thinking=True)
    except discord.errors.InteractionResponded:
        return

    try:
        session = await load_session_state()
        if not session:
            await interaction.followup.send("‚ö†Ô∏è Session –∞—á–∞–∞–ª–∞—Ö–∞–¥ –∞–ª–¥–∞–∞ –≥–∞—Ä–ª–∞–∞.")
            return

        player_ids = session.get("player_ids", []) or []
        if not player_ids:
            await interaction.followup.send("üì≠ –û–¥–æ–æ–≥–æ–æ—Ä –±“Ø—Ä—Ç–≥—ç–≥–¥—Å—ç–Ω —Ç–æ–≥–ª–æ–≥—á –∞–ª–≥–∞.")
            return

        guild = interaction.guild

        # ‚úÖ –ù—ç–≥ –¥–æ—Ä –∞–≤–∞–∞–¥ DB round-trip –±–∞–≥–∞—Å–≥–∞–Ω–∞
        all_scores = await get_all_scores()  # { "uid": {tier, score, ...}, ... }

        # üî¢ –º”©—Ä –±“Ø—Ä–∏–π–Ω –º—ç–¥—ç—ç–ª–ª–∏–π–≥ –ø–∞—Ä–∞–ª–ª–µ–ª—å –±—ç–ª–¥—ç—Ö
        async def build_row(uid: int):
            member = guild.get_member(uid)
            name = member.display_name if member else f"{uid}"
            data = all_scores.get(str(uid)) or get_default_tier()
            tier = data.get("tier", "4-1")
            score = int(data.get("score", 0))
            weight = TIER_WEIGHT.get(tier, 0) + score
            perf = await get_performance_emoji(uid)  # ‚úÖ/‚ùå/‚è∏/‚ûñ
            return (uid, name, tier, score, weight, perf)

        rows = await asyncio.gather(*[build_row(uid) for uid in player_ids])

        # üìä –ñ–∏–Ω–≥—ç—ç—Ä (–∏—Ö—ç—ç—Å –±–∞–≥–∞–¥) —ç—Ä—ç–º–±—ç–ª–Ω—ç
        rows.sort(key=lambda r: r[4], reverse=True)

        # üñº Embed –±—ç–ª–¥—å–µ
        emb = discord.Embed(
            title=f"üìã –ë“Ø—Ä—Ç–≥—ç–≥–¥—Å—ç–Ω —Ç–æ–≥–ª–æ–≥—á–∏–¥ ‚Äî {len(rows)}",
            description="–ñ–∏–Ω (tier+score)‚Äë—ç—ç—Ä —ç—Ä—ç–º–±—ç–ª—Å—ç–Ω –∂–∞–≥—Å–∞–∞–ª—Ç.",
            color=0xF1C40F
        )

        # –º”©—Ä“Ø“Ø–¥–∏–π–≥ 10-–∞–∞—Ä –Ω—å –±–∞–≥—Ü–∞–ª–∂ —Ç–∞–ª–±–∞—Ä—É—É–¥–∞–¥ —Ö–∏–π–Ω—ç (Discord field limit —Ö–∞–º–≥–∞–∞–ª–Ω–∞)
        lines = [
            f"- {name} ‚Äî `{tier} | {score:+}` ¬∑ w:`{weight}` {perf}"
            for (_uid, name, tier, score, weight, perf) in rows
        ]
        parts = ["\n".join(lines[i:i+10]) for i in range(0, len(lines), 10)]

        if parts:
            emb.add_field(name="üë• –¢–æ–≥–ª–æ–≥—á–∏–¥", value=parts[0], inline=False)
            for extra in parts[1:]:
                emb.add_field(name="\u200B", value=extra, inline=False)  # zero-width header
        else:
            emb.add_field(name="üë• –¢–æ–≥–ª–æ–≥—á–∏–¥", value="‚Äî", inline=False)

        # üí° –ñ–∏–∂–∏–≥ –∑”©–≤–ª”©–º–∂
        team_count = session.get("team_count") or 2
        ppl_per = session.get("players_per_team") or 5
        emb.set_footer(text=f"Tip: /go_bot {team_count} {ppl_per} —ç—Å–≤—ç–ª /go_gpt {team_count} {ppl_per}")

        await interaction.followup.send(embed=emb)

    except Exception as e:
        print("‚ùå show_added_players –∞–ª–¥–∞–∞:", e)
        await interaction.followup.send("‚ö†Ô∏è –¢–æ–≥–ª–æ–≥—á–¥—ã–≥ —Ö–∞—Ä—É—É–ª–∞—Ö “Ø–µ–¥ –∞–ª–¥–∞–∞ –≥–∞—Ä–ª–∞–∞.")

@bot.tree.command(name="remove", description="–¢–æ–≥–ª–æ–≥—á ”©”©—Ä–∏–π–≥”©”© –±“Ø—Ä—Ç–≥—ç–ª—ç—ç—Å —Ö–∞—Å–Ω–∞")
async def remove(interaction: discord.Interaction):
    try:
        await interaction.response.defer(thinking=True)
    except discord.errors.InteractionResponded:
        return

    try:
        user_id = interaction.user.id
        session = await load_session_state()
        if not session or not session.get("active"):
            await interaction.followup.send("‚ö†Ô∏è Session –∏–¥—ç–≤—Ö–≥“Ø–π –±–∞–π–Ω–∞.")
            return

        player_ids = session.get("player_ids", [])
        if user_id not in player_ids:
            await interaction.followup.send("‚ùå –¢–∞ –±“Ø—Ä—Ç–≥—ç–ª–¥ –±–∞–π—Ö–≥“Ø–π –±–∞–π–Ω–∞.")
            return

        try:
            player_ids.remove(user_id)
            session["player_ids"] = player_ids
        except ValueError:
            await interaction.followup.send("‚ö†Ô∏è –¢–∞ –±“Ø—Ä—Ç–≥—ç–ª—ç—ç—Å –∞–ª—å —Ö—ç–¥–∏–π–Ω —Ö–∞—Å–∞–≥–¥—Å–∞–Ω –±–∞–π–Ω–∞.")
            return
        # üß† datetime —Ö”©—Ä–≤“Ø“Ø–ª—ç–ª—Ç
        if isinstance(session.get("start_time"), str):
            session["start_time"] = datetime.fromisoformat(session["start_time"])
        if isinstance(session.get("last_win_time"), str):
            session["last_win_time"] = datetime.fromisoformat(session["last_win_time"])

        await save_session_state(session)

        await interaction.followup.send(
            f"üóë {interaction.user.mention} –±“Ø—Ä—Ç–≥—ç–ª—ç—ç—Å —Ö–∞—Å–∞–≥–¥–ª–∞–∞.\n“Æ–ª–¥—Å—ç–Ω: **{len(player_ids)}** —Ç–æ–≥–ª–æ–≥—á"
        )
    except Exception as e:
        print("‚ùå /remove command –±“Ø—Ö—ç–ª–¥—ç—ç –∞–ª–¥–∞–∞:", e)
        await interaction.followup.send("‚ö†Ô∏è –•–∞—Å–∞—Ö “Ø–µ–¥ –∞–ª–¥–∞–∞ –≥–∞—Ä–ª–∞–∞.")

@bot.tree.command(name="remove_user", description="–ê–¥–º–∏–Ω: —Ç–æ–≥–ª–æ–≥—á–∏–π–≥ –±“Ø—Ä—Ç–≥—ç–ª—ç—ç—Å —Ö–∞—Å–Ω–∞")
@app_commands.describe(mention="–•–∞—Å–∞—Ö —Ç–æ–≥–ª–æ–≥—á–∏–π–≥ mention —Ö–∏–π–Ω—ç")
async def remove_user(interaction: discord.Interaction, mention: str):
    if not interaction.user.guild_permissions.administrator:
        await interaction.response.send_message("‚õîÔ∏è –ó”©–≤—Ö”©–Ω –∞–¥–º–∏–Ω —Ö—ç—Ä—ç–≥–ª—ç–Ω—ç.", ephemeral=True)
        return

    try:
        await interaction.response.defer(thinking=True)
    except discord.errors.InteractionResponded:
        return

    try:
        user_ids = [int(word[2:-1].replace("!", "")) for word in mention.split() if word.startswith("<@") and word.endswith(">")]
    except Exception as e:
        print("‚ùå Mention parse –∞–ª–¥–∞–∞:", e)
        await interaction.followup.send("‚ö†Ô∏è Mention parse —Ö–∏–π—Ö—ç–¥ –∞–ª–¥–∞–∞ –≥–∞—Ä–ª–∞–∞.")
        return

    if not user_ids:
        await interaction.followup.send("‚ö†Ô∏è –ó”©–≤ mention —Ö–∏–π–≥—ç—ç–≥“Ø–π –±–∞–π–Ω–∞.")
        return

    session = await load_session_state()
    if not session or not session.get("active"):
        await interaction.followup.send("‚ö†Ô∏è Session –∏–¥—ç–≤—Ö–≥“Ø–π –±–∞–π–Ω–∞.")
        return

    player_ids = session.get("player_ids", [])
    removed = 0

    for uid in user_ids:
        if uid in player_ids:
            player_ids.remove(uid)
            removed += 1

    session["player_ids"] = player_ids
    # ‚úÖ datetime —Ö”©—Ä–≤“Ø“Ø–ª—ç–ª—Ç
    if isinstance(session.get("start_time"), str):
        session["start_time"] = datetime.fromisoformat(session["start_time"])
    if isinstance(session.get("last_win_time"), str):
        session["last_win_time"] = datetime.fromisoformat(session["last_win_time"])

    try:
        await save_session_state(session)
    except Exception as e:
        print("‚ùå save_session_state –∞–ª–¥–∞–∞:", e)

    if removed == 0:
        await interaction.followup.send("‚ÑπÔ∏è –ë“Ø—Ä—Ç–≥—ç–ª—ç—ç—Å —Ö–∞—Å–∞–≥–¥—Å–∞–Ω —Ç–æ–≥–ª–æ–≥—á –æ–ª–¥—Å–æ–Ω–≥“Ø–π.")
    else:
        await interaction.followup.send(f"üóë {removed} —Ç–æ–≥–ª–æ–≥—á –±“Ø—Ä—Ç–≥—ç–ª—ç—ç—Å —Ö–∞—Å–∞–≥–¥–ª–∞–∞.")

@bot.tree.command(name="set_match", description="–ê–¥–º–∏–Ω: –≥–∞—Ä–∞–∞—Ä –±–∞–≥ –±“Ø—Ä–¥“Ø“Ø–ª–Ω—ç")
@app_commands.describe(team_number="–ë–∞–≥–∏–π–Ω –¥—É–≥–∞–∞—Ä", mentions="–¢–æ–≥–ª–æ–≥—á–¥—ã–≥ mention —Ö–∏–π–Ω—ç")
async def set_match(interaction: discord.Interaction, team_number: int, mentions: str):
    if not interaction.user.guild_permissions.administrator:
        await interaction.response.send_message("‚õîÔ∏è –ó”©–≤—Ö”©–Ω –∞–¥–º–∏–Ω —Ö—ç—Ä—ç–≥–ª—ç–Ω—ç.", ephemeral=True)
        return

    try:
        await interaction.response.defer(ephemeral=True)
    except discord.errors.InteractionResponded:
        return

    try:
        user_ids = [int(word[2:-1].replace("!", "")) for word in mentions.split() if word.startswith("<@") and word.endswith(">")]
    except Exception as e:
        print("‚ùå mention parse –∞–ª–¥–∞–∞:", e)
        await interaction.followup.send("‚ö†Ô∏è Mention parse —Ö–∏–π—Ö—ç–¥ –∞–ª–¥–∞–∞ –≥–∞—Ä–ª–∞–∞.", ephemeral=True)
        return

    if not user_ids:
        await interaction.followup.send("‚ö†Ô∏è –•–∞–º–≥–∏–π–Ω –±–∞–≥–∞–¥–∞–∞ –Ω—ç–≥ —Ç–æ–≥–ª–æ–≥—á mention —Ö–∏–π–Ω—ç “Ø“Ø.", ephemeral=True)
        return

    session = await load_session_state()
    now = datetime.now(timezone.utc)

    if not session or not session.get("active"):
        # Session –±–∞–π—Ö–≥“Ø–π –±–æ–ª —à–∏–Ω—ç—ç—Ä —ç—Ö–ª“Ø“Ø–ª–Ω—ç
        session = {
            "active": True,
            "start_time": now.isoformat(),
            "last_win_time": now.isoformat(),
            "initiator_id": interaction.user.id,
            "team_count": team_number,
            "players_per_team": 5,
            "player_ids": [],
            "teams": [],
            "changed_players": [],
            "strategy": ""
        }

    teams = session.get("teams", [])
    player_ids = session.get("player_ids", [])

    # ‚ö†Ô∏è –î–∞–≤—Ö–∞—Ä–¥–∞–ª —à–∞–ª–≥–∞–Ω–∞
    all_existing_ids = [uid for team in teams for uid in team]
    duplicate_ids = [uid for uid in user_ids if uid in all_existing_ids]
    if duplicate_ids:
        await interaction.followup.send("üö´ –ó–∞—Ä–∏–º —Ç–æ–≥–ª–æ–≥—á –∞–ª—å –Ω—ç–≥ –±–∞–≥—Ç –±“Ø—Ä—Ç–≥—ç–≥–¥—Å—ç–Ω –±–∞–π–Ω–∞.", ephemeral=True)
        return

    # üîß teams[] –±–∞–π—Ö–≥“Ø–π –±–æ–ª “Ø“Ø—Å–≥—ç–Ω—ç
    while len(teams) < team_number:
        teams.append([])

    teams[team_number - 1] = user_ids

    for uid in user_ids:
        if uid not in player_ids:
            player_ids.append(uid)

    session["teams"] = teams
    session["player_ids"] = player_ids
    session["team_count"] = max(team_number, session.get("team_count", 2))
    session["initiator_id"] = session.get("initiator_id") or interaction.user.id

    try:
        await save_session_state(session)
    except Exception as e:
        print("‚ùå save_session_state –∞–ª–¥–∞–∞:", e)

    await interaction.followup.send(f"‚úÖ {len(user_ids)} —Ç–æ–≥–ª–æ–≥—á–∏–π–≥ {team_number}-—Ä –±–∞–≥—Ç –±“Ø—Ä—Ç–≥—ç–ª—ç—ç.")

@bot.tree.command(name="clear_match", description="–ê–¥–º–∏–Ω: –æ–¥–æ–æ–≥–∏–π–Ω –∏–¥—ç–≤—Ö—Ç—ç–π match-–∏–π–Ω –±–∞–≥ –±“Ø—Ä—Ç–≥—ç–ª–∏–π–≥ —Ü—ç–≤—ç—Ä–ª—ç–Ω—ç")
async def clear_match(interaction: discord.Interaction):
    if not interaction.user.guild_permissions.administrator:
        await interaction.response.send_message("‚õîÔ∏è –ó”©–≤—Ö”©–Ω –∞–¥–º–∏–Ω —Ö—ç—Ä—ç–≥–ª—ç–Ω—ç.", ephemeral=True)
        return

    try:
        await interaction.response.defer(thinking=True)
    except discord.errors.InteractionResponded:
        return

    try:
        await clear_session_state()
        await interaction.followup.send("üßº Session –±“Ø—Ä—ç–Ω —Ü—ç–≤—ç—Ä–ª—ç–≥–¥–ª—ç—ç.")
    except Exception as e:
        print("‚ùå clear_session_state –∞–ª–¥–∞–∞:", e)
        await interaction.followup.send("‚ö†Ô∏è Session —Ü—ç–≤—ç—Ä–ª—ç—Ö “Ø–µ–¥ –∞–ª–¥–∞–∞ –≥–∞—Ä–ª–∞–∞.")

@bot.tree.command(name="go_bot", description="–û–Ω–æ–æ–Ω—ã –¥–∞–≥—É—É —Ç—ç–Ω—Ü–≤—ç—Ä—Ç—ç–π –±–∞–≥ —Ö—É–≤–∞–∞—Ä–∏–ª–Ω–∞")
@app_commands.describe(team_count="–•—ç–¥—ç–Ω –±–∞–≥—Ç–∞–π –±–∞–π—Ö –≤—ç", players_per_team="–ù—ç–≥ –±–∞–≥—Ç —Ö—ç–¥—ç–Ω —Ö“Ø–Ω –±–∞–π—Ö –≤—ç")
async def go_bot(interaction: discord.Interaction, team_count: int, players_per_team: int):
    try:
        await interaction.response.defer(thinking=True)
    except discord.errors.InteractionResponded:
        return

    session = await load_session_state()
    if not session or not session.get("active"):
        await interaction.followup.send("‚ö†Ô∏è Session –∏–¥—ç–≤—Ö–≥“Ø–π –±–∞–π–Ω–∞.", ephemeral=True)
        return

    is_admin = interaction.user.guild_permissions.administrator
    is_initiator = interaction.user.id == session.get("initiator_id")
    if not (is_admin or is_initiator):
        await interaction.followup.send("‚õîÔ∏è –ó”©–≤—Ö”©–Ω –∞–¥–º–∏–Ω —ç—Å–≤—ç–ª session —ç—Ö–ª“Ø“Ø–ª—Å—ç–Ω —Ö“Ø–Ω –∞–∂–∏–ª–ª—É—É–ª–∂ —á–∞–¥–Ω–∞.", ephemeral=True)
        return

    total_slots = team_count * players_per_team
    player_ids = session.get("player_ids", [])

    if not player_ids:
        await interaction.followup.send("‚ö†Ô∏è –ë“Ø—Ä—Ç–≥—ç–≥–¥—Å—ç–Ω —Ç–æ–≥–ª–æ–≥—á –∞–ª–≥–∞ –±–∞–π–Ω–∞.", ephemeral=True)
        return

    # ‚úÖ –û–Ω–æ–æ + tier-–∏–π–Ω –∂–∏–Ω
    player_weights = {}
    for uid in player_ids:
        data = await get_score(uid) or get_default_tier()
        player_weights[uid] = calculate_weight(data)

    sorted_players = sorted(player_weights.items(), key=lambda x: x[1], reverse=True)
    trimmed_players = sorted_players[:total_slots]
    trimmed_weights = dict(trimmed_players)
    left_out_players = sorted_players[total_slots:]

    # üß† 3 —Å—Ç—Ä–∞—Ç–µ–≥–∏
    snake = snake_teams(trimmed_weights, team_count, players_per_team)
    greedy = greedy_teams(trimmed_weights, team_count, players_per_team)
    reflector = reflector_teams(trimmed_weights, team_count, players_per_team)

    strategy_diffs = {
        "snake": (snake, total_weight_difference(snake, trimmed_weights)),
        "greedy": (greedy, total_weight_difference(greedy, trimmed_weights)),
        "reflector": (reflector, total_weight_difference(reflector, trimmed_weights))
    }

    strategy, (best_teams, best_diff) = min(strategy_diffs.items(), key=lambda x: x[1][1])

    # üíæ Session —Ö–∞–¥–≥–∞–ª–∞—Ö
    session["team_count"] = team_count
    session["players_per_team"] = players_per_team
    session["teams"] = best_teams
    session["strategy"] = strategy
    session["last_win_time"] = datetime.now(timezone.utc).isoformat()

    try:
        await save_session_state(session, allow_empty=True)
    except Exception as e:
        print("‚ùå save_session_state –∞–ª–¥–∞–∞ /go_bot:", e)

    # üÜï Embed render
    is_ranked = players_per_team in [4, 5] and team_count >= 2
    try:
        await send_team_assignment_embed(
            interaction,
            title_prefix="Bot",
            strategy_note=f"`{strategy}` (diff={best_diff})",
            team_count=team_count,
            players_per_team=players_per_team,
            teams=best_teams,
            weights_map=trimmed_weights,               # {uid: weight}
            left_out=[uid for uid, _ in left_out_players],
            ranked=is_ranked
        )
    except Exception:
        traceback.print_exc()


@bot.tree.command(name="go_gpt", description="GPT-—ç—ç—Ä –æ–Ω–æ–æ–Ω—ã –±–∞–ª–∞–Ω—Å —Ö–∏–π–∂ –±–∞–≥ —Ö—É–≤–∞–∞—Ä–∏–ª–Ω–∞")
@app_commands.describe(
    team_count="–ë–∞–≥–∏–π–Ω —Ç–æ–æ (–∂–∏—à—ç—ç: 2)",
    players_per_team="–ù—ç–≥ –±–∞–≥—Ç —Ö—ç–¥—ç–Ω —Ç–æ–≥–ª–æ–≥—á –±–∞–π—Ö –≤—ç (–∂–∏—à—ç—ç: 5)"
)
async def go_gpt(interaction: discord.Interaction, team_count: int, players_per_team: int):
    session = await load_session_state()
    if not session or not session.get("active"):
        await interaction.response.send_message("‚ö†Ô∏è Session –∏–¥—ç–≤—Ö–≥“Ø–π –±–∞–π–Ω–∞.", ephemeral=True)
        return

    is_admin = interaction.user.guild_permissions.administrator
    is_initiator = interaction.user.id == session.get("initiator_id")
    if not (is_admin or is_initiator):
        await interaction.response.send_message("‚ùå –ó”©–≤—Ö”©–Ω admin —ç—Å–≤—ç–ª —Ç–æ—Ö–∏—Ä–≥–æ–æ–≥ —ç—Ö–ª“Ø“Ø–ª—Å—ç–Ω —Ö“Ø–Ω –∞–∂–∏–ª–ª—É—É–ª–∂ —á–∞–¥–Ω–∞.", ephemeral=True)
        return

    if team_count < 2 or players_per_team < 1:
        await interaction.response.send_message("‚ö†Ô∏è –ë–∞–≥–∏–π–Ω —Ç–æ–æ ‚â• 2, —Ç–æ–≥–ª–æ–≥—á–∏–π–Ω —Ç–æ–æ ‚â• 1 –±–∞–π—Ö —ë—Å—Ç–æ–π.", ephemeral=True)
        return

    try:
        await interaction.response.defer(thinking=True)
    except discord.errors.InteractionResponded:
        return

    total_slots = team_count * players_per_team
    player_ids = session.get("player_ids", []) or []

    if not player_ids:
        await interaction.followup.send("‚ö†Ô∏è –ë“Ø—Ä—Ç–≥—ç–≥–¥—Å—ç–Ω —Ç–æ–≥–ª–æ–≥—á –∞–ª–≥–∞ –±–∞–π–Ω–∞.", ephemeral=True)
        return

    # üî¢ –ñ–∏–Ω (tier + score)
    all_scores = []
    for uid in player_ids:
        data = await get_score(uid) or get_default_tier()
        power = TIER_WEIGHT.get(data.get("tier", "4-1"), 0) + data.get("score", 0)
        all_scores.append({"id": uid, "power": power})

    sorted_players = sorted(all_scores, key=lambda x: x["power"], reverse=True)
    selected_players = sorted_players[:total_slots]         # —è–≥ –¥“Ø“Ø—Ä–≥—ç—Ö —Ç–æ–æ–≥–æ–æ—Ä —Ö–∞–π—á–∏–ª–∂ –∞–≤–Ω–∞
    left_out_players = sorted_players[total_slots:]
    weights = {p["id"]: p["power"] for p in selected_players}
    allowed_ids = {p["id"] for p in selected_players}

    # üßΩ Sanitize helper
    def sanitize(teams, team_count, players_per_team, allowed_ids):
        if not isinstance(teams, list) or len(teams) != team_count:
            return None
        clean = []
        seen = set()
        for t in teams:
            if not isinstance(t, list):
                return None
            row = []
            for u in t:
                try:
                    u = int(u)
                except:
                    continue
                if u in allowed_ids and u not in seen and len(row) < players_per_team:
                    row.append(u); seen.add(u)
            clean.append(row)

        # –¥—É—Ç—É—É–≥ –Ω”©—Ö”©—Ö
        remaining = [u for u in allowed_ids if u not in seen]
        for i in range(team_count):
            while len(clean[i]) < players_per_team and remaining:
                clean[i].append(remaining.pop())

        # –≤–∞–ª–∏–¥
        if any(len(x) != players_per_team for x in clean):
            return None
        return clean

    # ü§ñ GPT –¥—É—É–¥–∞—Ö
    try:
        raw = await call_gpt_balance_api(team_count, players_per_team, selected_players)
    except Exception as e:
        print("‚ùå GPT API error:", e)
        traceback.print_exc()
        await interaction.followup.send("‚ö†Ô∏è GPT –¥—É—É–¥–ª–∞–≥–∞ –∞–º–∂–∏–ª—Ç–≥“Ø–π. –¢“Ø—Ä `/go_bot` —ç—Å–≤—ç–ª –¥–∞—Ä–∞–∞ –¥–∞—Ö–∏–Ω –æ—Ä–æ–ª–¥–æ–Ω–æ —É—É.")
        return

    teams = sanitize(raw, team_count, players_per_team, allowed_ids)
    if teams is None:
        await interaction.followup.send("‚ö†Ô∏è GPT –±—É—Ü–∞–∞—Å–∞–Ω –±“Ø—Ç—ç—Ü –±—É—Ä—É—É –±–∞–π–ª–∞–∞. `/go_bot` –∞—à–∏–≥–ª–∞–Ω–∞ —É—É.")
        return

    # üîß GPT –≥–∞—Ä—Ü—ã–≥ –ª–æ–∫–∞–ª —Å–∞–π–∂—Ä—É—É–ª–∞–ª—Ç (swap) ‚Äì –∑–∞—Ä–¥–ª—ã–≥ —É–ª–∞–º –±—É—É—Ä—É—É–ª–Ω–∞
    refined_teams, cost = local_refine(teams, weights, max_rounds=300)

    # üíæ Session
    session["team_count"] = team_count
    session["players_per_team"] = players_per_team
    session["teams"] = refined_teams
    session["strategy"] = f"gpt+local_refine(cost={cost})"
    session["last_win_time"] = datetime.now(timezone.utc).isoformat()
    session["player_ids"] = list(weights.keys())

    await save_session_state(session, allow_empty=True)

    # ‚ö° Performance emoji (–∫—ç—à—Ç—ç–π)
    perf_cache = {}
    async def perf(uid: int) -> str:
        if uid not in perf_cache:
            perf_cache[uid] = await get_performance_emoji(uid)
        return perf_cache[uid]

    # üÜï Embed render
    is_ranked = players_per_team in [4, 5] and team_count >= 2
    try:
        await send_team_assignment_embed(
            interaction,
            title_prefix="GPT",
            strategy_note=f"`gpt+local_refine` (cost={cost})",
            team_count=team_count,
            players_per_team=players_per_team,
            teams=refined_teams,
            weights_map=weights,                        # {uid: power}
            left_out=[p["id"] for p in left_out_players],
            ranked=is_ranked
        )
    except Exception:
        traceback.print_exc()


@bot.tree.command(name="set_match_result", description="Match –±“Ø—Ä—Ç–≥—ç–Ω—ç, +1/-1 –æ–Ω–æ–æ, tier ”©”©—Ä—á–∏–ª–Ω”©")
@app_commands.describe(
    winner_teams="–Ø–ª—Å–∞–Ω –±–∞–≥—É—É–¥—ã–Ω –¥—É–≥–∞–∞—Ä—É—É–¥ (–∂–∏—à—ç—ç: 1 3)",
    loser_teams="–Ø–ª–∞–≥–¥—Å–∞–Ω –±–∞–≥—É—É–¥—ã–Ω –¥—É–≥–∞–∞—Ä—É—É–¥ (–∂–∏—à—ç—ç: 2 4)"
)
async def set_match_result(interaction: discord.Interaction, winner_teams: str, loser_teams: str):
    try:
        await interaction.response.defer(thinking=True)
    except discord.errors.InteractionResponded:
        return

    session = await load_session_state()
    if not session:
        await interaction.followup.send("‚ö†Ô∏è Session –º—ç–¥—ç—ç–ª—ç–ª –æ–ª–¥—Å–æ–Ω–≥“Ø–π.")
        return

    ranked = session.get("players_per_team") in [4, 5] and session.get("team_count", 0) >= 2
    if not ranked:
        await interaction.followup.send("‚ÑπÔ∏è –≠–Ω—ç match –Ω—å **Ranked –±–∏—à** —Ç—É–ª –æ–Ω–æ–æ, tier ”©”©—Ä—á–ª”©–≥–¥”©—Ö–≥“Ø–π. –ì—ç—Ö–¥—ç—ç –±“Ø—Ä—Ç–≥—ç–ª —Ö–∞–¥–≥–∞–ª–∞–≥–¥–∞–Ω–∞.")

    is_admin = interaction.user.guild_permissions.administrator
    is_initiator = interaction.user.id == session.get("initiator_id")
    if not (is_admin or is_initiator):
        await interaction.followup.send("‚õîÔ∏è –ó”©–≤—Ö”©–Ω –∞–¥–º–∏–Ω —ç—Å–≤—ç–ª session —ç—Ö–ª“Ø“Ø–ª—Å—ç–Ω —Ö“Ø–Ω –∞–∂–∏–ª–ª—É—É–ª–∂ —á–∞–¥–Ω–∞.")
        return

    try:
        win_indexes = [int(x.strip()) - 1 for x in winner_teams.strip().split()]
        lose_indexes = [int(x.strip()) - 1 for x in loser_teams.strip().split()]
    except ValueError:
        await interaction.followup.send("‚ö†Ô∏è –ë–∞–≥–∏–π–Ω –¥—É–≥–∞–∞—Ä—É—É–¥—ã–≥ –∑”©–≤ –æ—Ä—É—É–ª–Ω–∞ —É—É (–∂: 1 3)")
        return

    all_teams = session.get("teams", [])
    if any(i < 0 or i >= len(all_teams) for i in win_indexes + lose_indexes):
        await interaction.followup.send("‚ö†Ô∏è –ë–∞–≥–∏–π–Ω –¥—É–≥–∞–∞—Ä –±—É—Ä—É—É –±–∞–π–Ω–∞.")
        return

    winners = [uid for i in win_indexes for uid in all_teams[i]]
    losers  = [uid for i in lose_indexes for uid in all_teams[i]]
    now = datetime.now(timezone.utc)
    guild = interaction.guild

    # üÜï winners/losers –±“Ø—Ö UID-–¥ scores-–¥ default –±–∏—á–ª—ç–≥ “Ø“Ø—Å–≥—ç–Ω—ç
    await ensure_scores_for_users(guild, list(set(winners + losers)))

    def validate_tier(tier): return tier if tier in TIER_ORDER else "4-1"

    def adjust_score(data, delta):
        data["score"] += delta
        if data["score"] >= 5:
            data["tier"] = promote_tier(data["tier"])
            data["score"] = 0
        elif data["score"] <= -5:
            data["tier"] = demote_tier(data["tier"])
            data["score"] = 0
        return data

    winner_details, loser_details = [], []

    # ‚úÖ WINNERS
    for uid in winners:
        try:
            data = await get_score(uid) or get_default_tier()
            old_score, old_tier = data["score"], data["tier"]
            data["tier"] = validate_tier(data["tier"])
            member = guild.get_member(uid)
            username = member.display_name if member else "Unknown"

            # –û–Ω–æ–æ/—Ç“Ø–π–≤—à–∏–Ω –∑”©–≤—Ö”©–Ω ranked “Ø–µ–¥
            if ranked:
                data = adjust_score(data, +1)
                await upsert_score(uid, data["score"], data["tier"], username)
                await update_player_stats(uid, is_win=True)

            # üÜï PERF LOG ‚Äî ranked‚Äë–∞–∞—Å “Ø–ª —Ö–∞–º–∞–∞—Ä–∞–Ω
            try:
                await log_score_result(uid, "win")
            except Exception as e:
                print("‚ö†Ô∏è log_score_result(win) –∞–ª–¥–∞–∞:", e)

            winner_details.append({
                "uid": uid, "username": username,
                "team": next((i+1 for i, team in enumerate(all_teams) if uid in team), None),
                "old_score": old_score, "new_score": data["score"],
                "old_tier": old_tier, "new_tier": data["tier"]
            })
        except Exception as e:
            print(f"‚ùå Winner uid:{uid} update fail:", e)

    # ‚ùå LOSERS
    for uid in losers:
        try:
            data = await get_score(uid) or get_default_tier()
            old_score, old_tier = data["score"], data["tier"]
            data["tier"] = validate_tier(data["tier"])
            member = guild.get_member(uid)
            username = member.display_name if member else "Unknown"

            if ranked:
                data = adjust_score(data, -1)
                await upsert_score(uid, data["score"], data["tier"], username)
                await update_player_stats(uid, is_win=False)

            # üÜï PERF LOG ‚Äî ranked‚Äë–∞–∞—Å “Ø–ª —Ö–∞–º–∞–∞—Ä–∞–Ω
            try:
                await log_score_result(uid, "loss")
            except Exception as e:
                print("‚ö†Ô∏è log_score_result(loss) –∞–ª–¥–∞–∞:", e)

            loser_details.append({
                "uid": uid, "username": username,
                "team": next((i+1 for i, team in enumerate(all_teams) if uid in team), None),
                "old_score": old_score, "new_score": data["score"],
                "old_tier": old_tier, "new_tier": data["tier"]
            })
        except Exception as e:
            print(f"‚ùå Loser uid:{uid} update fail:", e)

    # Nickname refresh
    try:
        await update_nicknames_for_users(guild, [p["uid"] for p in winner_details + loser_details])
    except Exception as e:
        print("‚ö†Ô∏è nickname update error:", e)

    # Match log
    try:
        print("‚úÖ insert_match —ç—Ö—ç–ª–∂ –±–∞–π–Ω–∞...")
        await clear_last_match()
        await save_last_match(winner_details or [], loser_details or [])
        await insert_match(
            initiator_id=session.get("initiator_id", 0),
            team_count=len(session.get("teams", [])),
            players_per_team=max(len(t) for t in session.get("teams", [])) if session.get("teams") else 0,
            winners=[int(uid) for uid in winners],
            losers=[int(uid) for uid in losers],
            mode="manual",
            strategy="NormalMatch",
            notes="set_match_result"
        )
        print("‚úÖ insert_match –∞–º–∂–∏–ª—Ç—Ç–∞–π –¥—É—É—Å–ª–∞–∞")
    except Exception as e:
        print("‚ùå Match log –∞–ª–¥–∞–∞:", e)
        traceback.print_exc()

    session["last_win_time"] = now.isoformat()
    try:
        await save_session_state(session)
    except Exception as e:
        print("‚ùå session save –∞–ª–¥–∞–∞:", e)

    # Render
    try:
        await send_match_result_embed(
            interaction,
            mode_label="Normal",
            ranked=ranked,
            win_indexes=win_indexes,
            lose_indexes=lose_indexes,
            winner_details=winner_details,
            loser_details=loser_details,
            session=session,
            weights_map={}  # —Ö“Ø—Å–≤—ç–ª weights dict ”©–≥—á –±–æ–ª–Ω–æ
        )
    except Exception:
        traceback.print_exc()

@bot.tree.command(name="set_match_result_fountain", description="Fountain match –±“Ø—Ä—Ç–≥—ç–Ω—ç, +2/-2 –æ–Ω–æ–æ, tier ”©”©—Ä—á–∏–ª–Ω”©")
@app_commands.describe(
    winner_teams="–Ø–ª—Å–∞–Ω –±–∞–≥—É—É–¥—ã–Ω –¥—É–≥–∞–∞—Ä—É—É–¥ (–∂–∏—à—ç—ç: 1 3)",
    loser_teams="–Ø–ª–∞–≥–¥—Å–∞–Ω –±–∞–≥—É—É–¥—ã–Ω –¥—É–≥–∞–∞—Ä—É—É–¥ (–∂–∏—à—ç—ç: 2 4)"
)
async def set_match_result_fountain(interaction: discord.Interaction, winner_teams: str, loser_teams: str):
    try:
        await interaction.response.defer(thinking=True)
    except discord.errors.InteractionResponded:
        return

    session = await load_session_state()
    if not session:
        await interaction.followup.send("‚ö†Ô∏è Session –º—ç–¥—ç—ç–ª—ç–ª –æ–ª–¥—Å–æ–Ω–≥“Ø–π.")
        return

    ranked = session.get("players_per_team") in [4, 5] and session.get("team_count", 0) >= 2
    if not ranked:
        await interaction.followup.send("‚ÑπÔ∏è –≠–Ω—ç match –Ω—å **Ranked –±–∏—à** —Ç—É–ª –æ–Ω–æ–æ, tier ”©”©—Ä—á–ª”©–≥–¥”©—Ö–≥“Ø–π. –ì—ç—Ö–¥—ç—ç –±“Ø—Ä—Ç–≥—ç–ª —Ö–∞–¥–≥–∞–ª–∞–≥–¥–∞–Ω–∞.")

    is_admin = interaction.user.guild_permissions.administrator
    is_initiator = interaction.user.id == session.get("initiator_id")
    if not (is_admin or is_initiator):
        await interaction.followup.send("‚õîÔ∏è –ó”©–≤—Ö”©–Ω –∞–¥–º–∏–Ω —ç—Å–≤—ç–ª session —ç—Ö–ª“Ø“Ø–ª—Å—ç–Ω —Ö“Ø–Ω –∞–∂–∏–ª–ª—É—É–ª–∂ —á–∞–¥–Ω–∞.")
        return

    try:
        win_indexes = [int(x.strip()) - 1 for x in winner_teams.strip().split()]
        lose_indexes = [int(x.strip()) - 1 for x in loser_teams.strip().split()]
    except ValueError:
        await interaction.followup.send("‚ö†Ô∏è –ë–∞–≥–∏–π–Ω –¥—É–≥–∞–∞—Ä—É—É–¥—ã–≥ –∑”©–≤ –æ—Ä—É—É–ª–Ω–∞ —É—É (–∂: 1 3)")
        return

    all_teams = session.get("teams", [])
    if any(i < 0 or i >= len(all_teams) for i in win_indexes + lose_indexes):
        await interaction.followup.send("‚ö†Ô∏è –ë–∞–≥–∏–π–Ω –¥—É–≥–∞–∞—Ä –±—É—Ä—É—É –±–∞–π–Ω–∞.")
        return

    winners = [uid for i in win_indexes for uid in all_teams[i]]
    losers  = [uid for i in lose_indexes for uid in all_teams[i]]
    now = datetime.now(timezone.utc)
    guild = interaction.guild

    # üÜï scores-–¥ default “Ø“Ø—Å–≥—ç–Ω—ç
    await ensure_scores_for_users(guild, list(set(winners + losers)))

    def validate_tier(tier): return tier if tier in TIER_ORDER else "4-1"
    def adjust_score(data, delta):
        data["score"] += delta
        if data["score"] >= 5:
            data["tier"] = promote_tier(data["tier"])
            data["score"] = 0
        elif data["score"] <= -5:
            data["tier"] = demote_tier(data["tier"])
            data["score"] = 0
        return data

    winner_details, loser_details = [], []

    for uid in winners:
        try:
            data = await get_score(uid) or get_default_tier()
            old_score, old_tier = data["score"], data["tier"]
            data["tier"] = validate_tier(data["tier"])
            member = guild.get_member(uid)
            username = member.display_name if member else "Unknown"

            if ranked:
                data = adjust_score(data, +2)
                await upsert_score(uid, data["score"], data["tier"], username)
                await update_player_stats(uid, is_win=True)

            # üÜï PERF LOG
            try:
                await log_score_result(uid, "win")
            except Exception as e:
                print("‚ö†Ô∏è log_score_result(win) –∞–ª–¥–∞–∞:", e)

            winner_details.append({
                "uid": uid, "username": username,
                "team": next((i+1 for i, team in enumerate(all_teams) if uid in team), None),
                "old_score": old_score, "new_score": data["score"],
                "old_tier": old_tier, "new_tier": data["tier"]
            })
        except Exception as e:
            print(f"‚ùå Winner uid:{uid} update fail:", e)

    for uid in losers:
        try:
            data = await get_score(uid) or get_default_tier()
            old_score, old_tier = data["score"], data["tier"]
            data["tier"] = validate_tier(data["tier"])
            member = guild.get_member(uid)
            username = member.display_name if member else "Unknown"

            if ranked:
                data = adjust_score(data, -2)
                await upsert_score(uid, data["score"], data["tier"], username)
                await update_player_stats(uid, is_win=False)

            # üÜï PERF LOG
            try:
                await log_score_result(uid, "loss")
            except Exception as e:
                print("‚ö†Ô∏è log_score_result(loss) –∞–ª–¥–∞–∞:", e)

            loser_details.append({
                "uid": uid, "username": username,
                "team": next((i+1 for i, team in enumerate(all_teams) if uid in team), None),
                "old_score": old_score, "new_score": data["score"],
                "old_tier": old_tier, "new_tier": data["tier"]
            })
        except Exception as e:
            print(f"‚ùå Loser uid:{uid} update fail:", e)

    try:
        await update_nicknames_for_users(guild, [p["uid"] for p in winner_details + loser_details])
    except Exception as e:
        print("‚ö†Ô∏è nickname update error:", e)

    try:
        await clear_last_match()
        await save_last_match(winner_details or [], loser_details or [])
        await insert_match(
            initiator_id=session.get("initiator_id", 0),
            team_count=len(session.get("teams", [])),
            players_per_team=max(len(t) for t in session.get("teams", [])) if session.get("teams") else 0,
            winners=winners,
            losers=losers,
            mode="manual",
            strategy="fountain",
            notes="set_match_result_fountain"
        )
    except Exception as e:
        print("‚ùå Match log –∞–ª–¥–∞–∞:", e)
        traceback.print_exc()

    session["last_win_time"] = now.isoformat()
    try:
        await save_session_state(session)
    except Exception as e:
        print("‚ùå session save –∞–ª–¥–∞–∞:", e)

    # Render
    try:
        await send_match_result_embed(
            interaction,
            mode_label="Fountain",
            ranked=ranked,
            win_indexes=win_indexes,
            lose_indexes=lose_indexes,
            winner_details=winner_details,
            loser_details=loser_details,
            session=session,
            weights_map={}  # —Ö“Ø—Å–≤—ç–ª weights dict ”©–≥—á –±–æ–ª–Ω–æ
        )
    except Exception:
        traceback.print_exc()

@bot.tree.command(name="change_player", description="–ë–∞–≥–∏–π–Ω –≥–∏—à“Ø“Ø–¥–∏–π–≥ —Å–æ–ª–∏—Ö")
@app_commands.describe(
    from_user="–ì–∞—Ä–∞—Ö —Ç–æ–≥–ª–æ–≥—á (@mention)",
    to_user="–û—Ä–æ—Ö —Ç–æ–≥–ª–æ–≥—á (@mention)"
)
async def change_player(interaction: discord.Interaction, from_user: discord.Member, to_user: discord.Member):
    try:
        await interaction.response.defer(thinking=True)
    except discord.errors.InteractionResponded:
        return

    session = await load_session_state()
    if not session or not session.get("active") or not session.get("teams"):
        await interaction.followup.send("‚ö†Ô∏è Session –∏–¥—ç–≤—Ö–≥“Ø–π —ç—Å–≤—ç–ª –±–∞–≥ –±“Ø—Ä–¥—ç—ç–≥“Ø–π –±–∞–π–Ω–∞.", ephemeral=True)
        return

    is_admin = interaction.user.guild_permissions.administrator
    is_initiator = interaction.user.id == session.get("initiator_id")
    if not (is_admin or is_initiator):
        await interaction.followup.send("‚õîÔ∏è –ó”©–≤—Ö”©–Ω –∞–¥–º–∏–Ω —ç—Å–≤—ç–ª session —ç—Ö–ª“Ø“Ø–ª—Å—ç–Ω —Ö“Ø–Ω —Å–æ–ª—å–∂ —á–∞–¥–Ω–∞.", ephemeral=True)
        return

    from_uid = from_user.id
    to_uid = to_user.id
    teams = session["teams"]

    from_team_index = None
    for i, team in enumerate(teams):
        if from_uid in team:
            from_team_index = i
            team.remove(from_uid)
            break

    if from_team_index is None:
        await interaction.followup.send("‚ùå –ì–∞—Ä–≥–∞—Ö —Ç–æ–≥–ª–æ–≥—á –±–∞–≥—Ç –±–∞–π—Ö–≥“Ø–π –±–∞–π–Ω–∞.", ephemeral=True)
        return

    # to_user –∞–ª—å –±–∞–≥—Ç –±–∞–π—Å–∞–Ω —á —Ö–∞–º–∞–∞–≥“Ø–π —Ö–∞—Å–Ω–∞
    for team in teams:
        if to_uid in team:
            team.remove(to_uid)

    # from_user –±–∞–π—Å–∞–Ω –±–∞–≥—Ç to_user-–≥ –æ—Ä—É—É–ª–Ω–∞
    teams[from_team_index].append(to_uid)

    changed = session.get("changed_players", [])
    if from_uid not in changed:
        changed.append(from_uid)
    if to_uid not in changed:
        changed.append(to_uid)
    session["changed_players"] = changed

    try:
        await save_session_state(session)
    except Exception as e:
        print("‚ùå session save –∞–ª–¥–∞–∞:", e)

    await interaction.followup.send(
        f"üîÅ **{from_user.display_name}** –±–∞–≥–∞–∞ –æ—Ä—Ö–∏–∂ **{to_user.display_name}** –æ—Ä–ª–æ–æ!\n"
        f"üìå {from_team_index+1}-—Ä –±–∞–≥—Ç —Å–æ–ª–∏–≥–¥–æ–ª—Ç —Ö–∏–π–≥–¥—Å—ç–Ω."
    )

@bot.tree.command(name="undo_last_match", description="–°“Ø“Ø–ª–¥ —Ö–∏–π—Å—ç–Ω match-–∏–π–Ω –æ–Ω–æ–æ–≥ –±—É—Ü–∞–∞–Ω–∞")
async def undo_last_match(interaction: discord.Interaction):
    try:
        await interaction.response.defer(thinking=True)
    except discord.errors.InteractionResponded:
        return

    try:
        session = await load_session_state()
        is_admin = interaction.user.guild_permissions.administrator
        is_initiator = interaction.user.id == session.get("initiator_id")
        if not (is_admin or is_initiator):
            await interaction.followup.send("‚õîÔ∏è –ó”©–≤—Ö”©–Ω –∞–¥–º–∏–Ω —ç—Å–≤—ç–ª session —ç—Ö–ª“Ø“Ø–ª—Å—ç–Ω —Ö“Ø–Ω –∞–∂–∏–ª–ª—É—É–ª–∂ —á–∞–¥–Ω–∞.", ephemeral=True)
            return

        last = await get_last_match()
        if not last:
            await interaction.followup.send("‚ö†Ô∏è –°“Ø“Ø–ª–¥ –±“Ø—Ä—Ç–≥—ç—Å—ç–Ω match –æ–ª–¥—Å–æ–Ω–≥“Ø–π.", ephemeral=True)
            return

        # üß© JSON parse
        winner_details = json.loads(last.get("winner_details", "[]"))
        loser_details = json.loads(last.get("loser_details", "[]"))
        guild = interaction.guild
        changed_ids = []

        async def restore_user(uid, old_score, old_tier):
            try:
                member = guild.get_member(uid)
                username = member.display_name if member else "Unknown"
                await upsert_score(uid, old_score, old_tier, username)
                changed_ids.append(uid)
            except Exception as e:
                print(f"‚ùå Undo fail uid:{uid} ‚Äì {e}")

        for p in winner_details + loser_details:
            await restore_user(p["uid"], p["old_score"], p["old_tier"])

        try:
            for p in winner_details:
                await update_player_stats(p["uid"], is_win=True, undo=True)
            for p in loser_details:
                await update_player_stats(p["uid"], is_win=False, undo=True)
        except Exception as e:
            print("‚ö†Ô∏è player_stats undo –∞–ª–¥–∞–∞:", e)

        # ‚úÖ Matches-—Å —Ö–∞–º–≥–∏–π–Ω —Å“Ø“Ø–ª–∏–π–Ω match-–∏–π–≥ id-–∞–∞—Ä –Ω—å —É—Å—Ç–≥–∞–Ω–∞
        try:
            conn = await connect()
            await conn.execute("DELETE FROM matches WHERE id = (SELECT MAX(id) FROM matches)")
            await conn.close()
        except Exception as e:
            print("‚ö†Ô∏è matches-—Å —É—Å—Ç–≥–∞—Ö “Ø–µ–¥ –∞–ª–¥–∞–∞:", e)

        # ‚úÖ Last match clear
        try:
            await clear_last_match()
        except Exception as e:
            print("‚ö†Ô∏è clear_last_match –∞–ª–¥–∞–∞:", e)

        try:
            await update_nicknames_for_users(guild, changed_ids)
        except Exception as e:
            print("‚ö†Ô∏è nickname update –∞–ª–¥–∞–∞:", e)

        win_mentions = " ".join(f"<@{p['uid']}>" for p in winner_details)
        lose_mentions = " ".join(f"<@{p['uid']}>" for p in loser_details)

        await interaction.followup.send(
            f"‚ôªÔ∏è Match –±—É—Ü–∞–∞–≥–¥–ª–∞–∞!\n"
            f"üèÜ Winner-—É—É–¥: {win_mentions}\n"
            f"üíÄ Loser-—É—É–¥: {lose_mentions}"
        )
        await interaction.followup.send("‚úÖ Match –±“Ø—Ä—Ç–≥—ç–ª —Ü—ç–≤—ç—Ä–ª—ç–≥–¥–ª—ç—ç.")
    except Exception as e:
        print("‚ùå Match –±—É—Ü–∞–∞—Ö “Ø–µ–¥ –∞–ª–¥–∞–∞ –≥–∞—Ä–ª–∞–∞:", e)
        await interaction.followup.send("‚ùå Match –±—É—Ü–∞–∞—Ö “Ø–µ–¥ –∞–ª–¥–∞–∞ –≥–∞—Ä–ª–∞–∞.")

@bot.tree.command(name="my_score", description="–¢–∞–Ω—ã –æ–Ω–æ–æ –±–æ–ª–æ–Ω tier-–≥ —Ö–∞—Ä—É—É–ª–Ω–∞")
async def my_score(interaction: discord.Interaction):
    try:
        await interaction.response.defer(thinking=True)  # ‚¨ÖÔ∏è public response
    except discord.errors.InteractionResponded:
        return

    uid = interaction.user.id
    data = await get_score(uid)

    if not data:
        await interaction.followup.send("‚ö†Ô∏è –¢–∞–Ω—ã –æ–Ω–æ–æ –±“Ø—Ä—Ç–≥—ç–ª–≥“Ø–π –±–∞–π–Ω–∞.")
        return

    tier = data.get("tier", "?")
    score = data.get("score", 0)
    username = data.get("username") or interaction.user.display_name

    await interaction.followup.send(
        f"üèÖ {username}:\n"
        f"Tier: **{tier}**\n"
        f"Score: **{score}**"
    )

@bot.tree.command(name="user_score", description="–ë—É—Å–∞–¥ —Ç–æ–≥–ª–æ–≥—á–∏–π–Ω –æ–Ω–æ–æ –±–æ–ª–æ–Ω tier-–≥ —Ö–∞—Ä—É—É–ª–Ω–∞")
@app_commands.describe(user="–û–Ω–æ–æ–≥ –Ω—å —Ö–∞—Ä–∞—Ö discord —Ö—ç—Ä—ç–≥–ª—ç–≥—á")
async def user_score(interaction: discord.Interaction, user: discord.Member):
    try:
        await interaction.response.defer(ephemeral=True)
    except discord.errors.InteractionResponded:
        return

    uid = user.id
    data = await get_score(uid)

    if not data:
        await interaction.followup.send(f"‚ö†Ô∏è {user.display_name} –æ–Ω–æ–æ –±“Ø—Ä—Ç–≥—ç–ª–≥“Ø–π –±–∞–π–Ω–∞.")
        return

    tier = data.get("tier", "4-1")
    score = data.get("score", 0)
    username = data.get("username") or user.display_name

    await interaction.followup.send(
        f"üèÖ {username}:\n"
        f"Tier: **{tier}**\n"
        f"Score: **{score}**"
    )

@bot.tree.command(name="player_stats", description="–¢–∞–Ω—ã –Ω–∏–π—Ç win/loss —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫")
async def player_stats(interaction: discord.Interaction):
    try:
        await interaction.response.defer(ephemeral=True)
    except discord.errors.InteractionResponded:
        return

    uid = interaction.user.id
    conn = await connect()
    row = await conn.fetchrow("SELECT wins, losses FROM player_stats WHERE uid = $1", uid)
    await conn.close()

    if not row:
        await interaction.followup.send("‚ö†Ô∏è –¢–∞–Ω—ã —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫ –±“Ø—Ä—Ç–≥—ç–ª–≥“Ø–π –±–∞–π–Ω–∞.")
        return

    wins = row["wins"] or 0
    losses = row["losses"] or 0
    total = wins + losses
    win_rate = (wins / total) * 100 if total > 0 else 0.0

    username = interaction.user.display_name

    await interaction.followup.send(
        f"üìä **{username} —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫**\n"
        f"üèÜ –Ø–ª–∞–ª—Ç: `{wins}` —Ç–æ–≥–ª–æ–ª—Ç\n"
        f"üíÄ –Ø–ª–∞–≥–¥–∞–ª: `{losses}` —Ç–æ–≥–ª–æ–ª—Ç\n"
        f"üìä Total: `{total}` —Ç–æ–≥–ª–æ–ª—Ç\n"
        f"üî• Win rate: `{win_rate:.1f}%`"
    )

@bot.tree.command(name="set_tier", description="–ê–¥–º–∏–Ω: —Ç–æ–≥–ª–æ–≥—á–∏–π–Ω tier –±–æ–ª–æ–Ω –æ–Ω–æ–æ–≥ –≥–∞—Ä –∞—Ä–≥–∞–∞—Ä —Ç–æ—Ö–∏—Ä—É—É–ª–Ω–∞")
@app_commands.describe(
    user="–•—ç—Ä—ç–≥–ª—ç–≥—á–∏–π–≥ –∑–∞–∞–Ω–∞ (@mention)",
    tier="–®–∏–Ω—ç tier (–∂: 3-2)",
    score="–û–Ω–æ–æ (default: 0)"
)
async def set_tier(interaction: discord.Interaction, user: discord.Member, tier: str, score: int = 0):
    if not interaction.user.guild_permissions.administrator:
        await interaction.response.send_message("‚õîÔ∏è –ó”©–≤—Ö”©–Ω –∞–¥–º–∏–Ω —Ç–æ—Ö–∏—Ä—É—É–ª–∂ —á–∞–¥–Ω–∞.", ephemeral=True)
        return

    tier_list = list(TIER_WEIGHT.keys())
    if tier not in tier_list:
        await interaction.response.send_message("‚ö†Ô∏è Tier —É—Ç–≥–∞ –±—É—Ä—É—É –±–∞–π–Ω–∞.", ephemeral=True)
        return

    uid = user.id
    username = user.display_name

    await upsert_score(uid, score, tier, username)
    await update_nicknames_for_users(interaction.guild, [uid])

    await interaction.response.send_message(
        f"‚úÖ {username}-–∏–π–Ω tier **{tier}**, score **{score}** –±–æ–ª–∂ —à–∏–Ω—ç—á–ª—ç–≥–¥–ª—ç—ç.", ephemeral=True
    )

@bot.tree.command(name="add_score", description="–¢–µ—Å—Ç: –æ–Ω–æ–æ –Ω—ç–º—ç—Ö")
@app_commands.describe(
    mentions="@mention —Ö—ç–ª–±—ç—Ä—ç—ç—Ä –∑–∞–∞–Ω–∞",
    points="–ù—ç–º—ç—Ö –æ–Ω–æ–æ (default: 1)"
)
async def add_score(interaction: discord.Interaction, mentions: str, points: int = 1):
    if not interaction.user.guild_permissions.administrator:
        await interaction.response.send_message("‚õîÔ∏è –ó”©–≤—Ö”©–Ω –∞–¥–º–∏–Ω —Ö—ç—Ä—ç–≥–ª—ç–Ω—ç.", ephemeral=True)
        return

    try:
        await interaction.response.defer(thinking=True)
    except discord.errors.InteractionResponded:
        return

    user_ids = [int(word[2:-1].replace("!", "")) for word in mentions.split() if word.startswith("<@") and word.endswith(">")]

    if not user_ids:
        await interaction.followup.send("‚ö†Ô∏è –•—ç—Ä—ç–≥–ª—ç–≥—á–∏–π–Ω mention –æ—Ä—É—É–ª–Ω–∞ —É—É.")
        return

    updated = []

    for uid in user_ids:
        member = interaction.guild.get_member(uid)
        if not member:
            continue

        data = await get_score(uid) or get_default_tier()
        data["username"] = member.display_name
        data["score"] += points

        score = data["score"]
        tier = data["tier"]

        while score >= 5:
            tier = promote_tier(tier)
            score = 0
        while score <= -5:
            tier = demote_tier(tier)
            score = 0

        data["score"] = score
        data["tier"] = tier

        await upsert_score(uid, score, tier, data["username"])
        updated.append(uid)

    try:
        await update_nicknames_for_users(interaction.guild, updated)
    except Exception as e:
        print("‚ö†Ô∏è nickname update error:", e)

    mentions_text = ", ".join(f"<@{uid}>" for uid in updated)
    lines = []
    for uid in updated:
        data = await get_score(uid)
        if not data:
            continue
        lines.append(f"<@{uid}>: {data['score']} (Tier: {data['tier']})")

    await interaction.followup.send("‚úÖ –û–Ω–æ–æ —à–∏–Ω—ç—á–ª—ç–≥–¥–ª—ç—ç:\n" + "\n".join(lines))

@bot.tree.command(name="add_donator", description="–ê–¥–º–∏–Ω: —Ç–æ–≥–ª–æ–≥—á–∏–π–≥ donator –±–æ–ª–≥–æ–Ω–æ")
@app_commands.describe(
    member="Donator –±–æ–ª–≥–æ—Ö —Ö—ç—Ä—ç–≥–ª—ç–≥—á",
    mnt="–•–∞–Ω–¥–∏–≤–ª–∞—Å–∞–Ω –º”©–Ω–≥”© (‚ÇÆ)"
)
async def add_donator(interaction: discord.Interaction, member: discord.Member, mnt: int):
    if not interaction.user.guild_permissions.administrator:
        await interaction.response.send_message("‚ùå –≠–Ω—ç –∫–æ–º–∞–Ω–¥—ã–≥ –∑”©–≤—Ö”©–Ω –∞–¥–º–∏–Ω —Ö—ç—Ä—ç–≥–ª—ç–≥—á –∞–∂–∏–ª–ª—É—É–ª–∂ —á–∞–¥–Ω–∞.", ephemeral=True)
        return

    try:
        await interaction.response.defer(thinking=True)
    except discord.errors.InteractionResponded:
        return

    await upsert_donator(member.id, mnt)
    await update_nicknames_for_users(interaction.guild, [member.id])

    await interaction.followup.send(
        f"üéâ {member.mention} —Ö—ç—Ä—ç–≥–ª—ç–≥—á–∏–π–≥ Donator –±–æ–ª–≥–æ–ª–æ–æ! (+{mnt:,}‚ÇÆ –Ω—ç–º—ç–≥–¥–ª—ç—ç)"
    )

@bot.tree.command(name="donator_list", description="Donator —Ö—ç—Ä—ç–≥–ª—ç–≥—á–¥–∏–π–Ω –∂–∞–≥—Å–∞–∞–ª—Ç")
async def donator_list(interaction: discord.Interaction):
    if not interaction.user.guild_permissions.administrator:
        return await interaction.response.send_message(
            "‚ùå –≠–Ω—ç –∫–æ–º–∞–Ω–¥—ã–≥ –∑”©–≤—Ö”©–Ω –∞–¥–º–∏–Ω —Ö—ç—Ä—ç–≥–ª—ç–≥—á –∞—à–∏–≥–ª–∞–∂ –±–æ–ª–Ω–æ.",
            ephemeral=True
        )

    try:
        await interaction.response.defer(thinking=True)

        donors = await get_all_donators()
        if not donors:
            return await interaction.followup.send("üì≠ Donator –±“Ø—Ä—Ç–≥—ç–ª –∞–ª–≥–∞ –±–∞–π–Ω–∞.")

        scores = await get_all_scores()

        # Donor-—É—É–¥—ã–≥ –Ω–∏–π—Ç –º”©–Ω–≥”©”©—Ä —ç—Ä—ç–º–±—ç–ª—ç—Ö
        sorted_donors = sorted(
            donors.items(),
            key=lambda x: x[1].get("total_mnt", 0),
            reverse=True
        )

        embed = discord.Embed(
            title="üíñ Donators",
            description="**–ú–∞–Ω–∞–π server-–≥ —Ö”©–≥–∂“Ø“Ø–ª–∂, –¥—ç–º–∂–∏–∂ –±—É–π –±“Ø—Ö Donator —Ö—ç—Ä—ç–≥–ª—ç–≥—á–∏–¥–¥—ç—ç –±–∞—è—Ä–ª–∞–ª–∞–∞!** üéâ",
            color=0xFFD700
        )

        top_emojis = ["ü•á", "ü•à", "ü•â"]
        total_sum = 0
        others_text = ""

        for i, (uid, data) in enumerate(sorted_donors, start=1):
            member = interaction.guild.get_member(int(uid))
            if not member:
                continue

            total = int(data.get("total_mnt", 0))
            total_sum += total
            tier = scores.get(uid, {}).get("tier", "4-1")
            nick = member.mention

            emoji = top_emojis[i-1] if i <= 3 else "‚ú®"
            value = f"{emoji} **{nick}** (Tier {tier}) ‚Äî **{total:,}‚ÇÆ**"

            if i == 1:
                embed.add_field(name="üèÜ Top Donators", value=value, inline=False)
            elif i <= 3:
                embed.add_field(name="\u200b", value=value, inline=False)
            else:
                others_text += f"\n{value}"

        # Top 3-—Å —Ö–æ–π—à—Ö–∏ –±“Ø—Ö –¥–æ–Ω–æ—Ä—É—É–¥—ã–≥ –Ω—ç–≥ field-–¥ –æ—Ä—É—É–ª–∞—Ö
        if others_text:
            embed.add_field(name="–ë—É—Å–∞–¥ –¥—ç–º–∂–∏–≥—á–∏–¥", value=others_text.strip(), inline=False)

        embed.set_footer(text=f"RZR Bot üåÄ | –î—ç–º–∂–ª—ç–≥–∏–π–Ω –Ω–∏–π—Ç –¥“Ø–Ω: {total_sum:,}‚ÇÆ")

        await interaction.followup.send(embed=embed)

    except Exception as e:
        print("‚ùå donator_list exception:", e)
        traceback.print_exc()
        await interaction.followup.send("‚ö†Ô∏è Donator –∂–∞–≥—Å–∞–∞–ª—Ç –∞–≤–∞—Ö–∞–¥ –∞–ª–¥–∞–∞ –≥–∞—Ä–ª–∞–∞.")

@bot.tree.command(name="help_info", description="Bot-—ã–Ω —Ç–∞–Ω–∏–ª—Ü—É—É–ª–≥–∞ (readme.md —Ñ–∞–π–ª—ã–≥ —Ö–∞—Ä—É—É–ª–Ω–∞)")
async def help_info(interaction: discord.Interaction):
    try:
        with open("Info/Readme.md", "r", encoding="utf-8") as f:
            content = f.read()
    except FileNotFoundError:
        await interaction.response.send_message("‚ö†Ô∏è `Readme.md` —Ñ–∞–π–ª –æ–ª–¥—Å–æ–Ω–≥“Ø–π.", ephemeral=True)
        return

    if len(content) > 1900:
        content = content[:1900] + "\n...\n(“Ø—Ä–≥—ç–ª–∂–ª—ç–ª—Ç—ç–π)"

    await interaction.response.send_message(
        f"üìò **RZR Bot –¢–∞–Ω–∏–ª—Ü—É—É–ª–≥–∞**\n```markdown\n{content}\n```",
        ephemeral=True
    )

@bot.tree.command(name="help_commands", description="–ë“Ø—Ö –∫–æ–º–∞–Ω–¥—ã–Ω —Ç–∞–π–ª–±–∞—Ä –∂–∞–≥—Å–∞–∞–ª—Ç")
async def help_commands(interaction: discord.Interaction):
    try:
        with open("Info/Commands_alt.md", "r", encoding="utf-8") as f:
            content = f.read()
    except FileNotFoundError:
        await interaction.response.send_message("‚ö†Ô∏è `Commands_alt.md` —Ñ–∞–π–ª –æ–ª–¥—Å–æ–Ω–≥“Ø–π.", ephemeral=True)
        return

    if len(content) > 1900:
        content = content[:1900] + "\n...\n(“Ø—Ä–≥—ç–ª–∂–ª—ç–ª—Ç—ç–π)"

    await interaction.response.send_message(
        f"üìí **RZR Bot –ö–æ–º–º–∞–Ω–¥—É—É–¥**\n```markdown\n{content}\n```",
        ephemeral=True
    )

@bot.tree.command(name="whois", description="Mention —Ö–∏–π—Å—ç–Ω —Ö—ç—Ä—ç–≥–ª—ç–≥—á–∏–π–Ω –Ω—ç—Ä–∏–π–≥ —Ö–∞—Ä—É—É–ª–Ω–∞")
@app_commands.describe(mention="–•—ç—Ä—ç–≥–ª—ç–≥—á–∏–π–Ω mention (@name) —Ö—ç–ª–±—ç—Ä—ç—ç—Ä")
async def whois(interaction: discord.Interaction, mention: str):
    try:
        await interaction.response.defer(ephemeral=True)
    except discord.errors.InteractionResponded:
        return

    try:
        uid = int(mention.strip("<@!>"))
        member = await interaction.guild.fetch_member(uid)
        await interaction.followup.send(
            f"üïµÔ∏è‚Äç‚ôÇÔ∏è –≠–Ω—ç ID: `{uid}`\n"
            f"üîó Mention: {member.mention}\n"
            f"üë§ Display Name: `{member.display_name}`",
            ephemeral=True
        )
    except Exception as e:
        await interaction.followup.send(f"‚ùå –û–ª–¥—Å–æ–Ω–≥“Ø–π: {e}", ephemeral=True)

@bot.tree.command(name="debug_id", description="–¢–∞–Ω—ã Discord ID-–≥ —Ö–∞—Ä—É—É–ª–Ω–∞")
async def debug_id(interaction: discord.Interaction):
    try:
        await interaction.response.defer(ephemeral=True)
    except discord.errors.InteractionResponded:
        return

    await interaction.followup.send(f"üÜî –¢–∞–Ω—ã Discord ID: `{interaction.user.id}`", ephemeral=True)

@bot.tree.command(name="current_match", description="–û–¥–æ–æ–≥–∏–π–Ω –∏–¥—ç–≤—Ö—Ç—ç–π session-–¥ —Ö—É–≤–∏–∞—Ä–ª–∞–≥–¥—Å–∞–Ω –±–∞–≥—É—É–¥—ã–≥ —Ö–∞—Ä—É—É–ª–Ω–∞")
async def current_match(interaction: discord.Interaction):
    try:
        await interaction.response.defer(thinking=True)
    except discord.errors.InteractionResponded:
        return

    # üß† Session DB-–æ–æ—Å –∞—á–∞–∞–ª–Ω–∞
    session = await load_session_state()
    if not session or not session.get("active"):
        await interaction.followup.send("‚ö†Ô∏è Session –∏–¥—ç–≤—Ö–≥“Ø–π –±–∞–π–Ω–∞.")
        return

    teams = session.get("teams", [])
    if not teams or not any(teams):
        await interaction.followup.send("üì≠ –ë–∞–≥—É—É–¥ —Ö–∞—Ä–∞–∞—Ö–∞–Ω —Ö—É–≤–∞–∞—Ä–∏–ª–∞–≥–¥–∞–∞–≥“Ø–π –±–∞–π–Ω–∞.")
        return

    all_scores = await get_all_scores()
    guild = interaction.guild
    msg_lines = []

    for i, team in enumerate(teams, start=1):
        total_score = sum(tier_score(all_scores.get(str(uid), {})) for uid in team)
        msg_lines.append(f"**üèÖ Team {i}** (–Ω–∏–π—Ç –æ–Ω–æ–æ: `{total_score}`):")

        for uid in team:
            data = all_scores.get(str(uid), {})
            tier = data.get("tier", "4-1")
            score = data.get("score", 0)
            member = guild.get_member(uid)
            name = member.display_name if member else f"`{uid}`"
            msg_lines.append(f"- {name} ({tier} | {score})")

        msg_lines.append("")  # newline

    await interaction.followup.send("\n".join(msg_lines))

@bot.tree.command(name="leaderboard", description="–¢–æ–ø 10 —Ç–æ–≥–ª–æ–≥—á–∏–π–Ω –æ–Ω–æ–æ, win/loss, winrate —Ö–∞—Ä—É—É–ª–Ω–∞")
async def leaderboard(interaction: discord.Interaction):
    try:
        await interaction.response.defer(thinking=True)
    except discord.errors.InteractionResponded:
        return

    all_scores = await get_all_scores()
    if not all_scores:
        await interaction.followup.send("üì≠ –û–Ω–æ–æ–Ω—ã –º—ç–¥—ç—ç–ª—ç–ª –±–∞–π—Ö–≥“Ø–π –±–∞–π–Ω–∞.")
        return

    # üßÆ Tier+score –Ω–∏–π–ª–±—ç—Ä—ç—ç—Ä —ç—Ä—ç–º–±—ç–ª–Ω—ç
    sorted_data = sorted(all_scores.items(), key=lambda x: tier_score(x[1]), reverse=True)
    uid_list = [int(uid) for uid, _ in sorted_data[:10]]

    # üìä Player stats SQL-–æ–æ—Å –∞–≤–∞—Ö–∞–∞—Ä —Ç–æ—Ö–∏—Ä—É—É–ª—Å–∞–Ω
    stat_rows = await get_player_stats(uid_list)
    stat_map = {str(row["uid"]): {"wins": row["wins"], "losses": row["losses"]} for row in stat_rows}

    lines = ["üèÖ **Leaderboard** ‚Äî Top 10 (Tier + Score | üèÜ/üíÄ ‚Äî Winrate%)"]
    for i, (uid, data) in enumerate(sorted_data[:10], 1):
        member = interaction.guild.get_member(int(uid))
        if not member:
            continue

        username = data.get("username") or member.display_name
        tier = data.get("tier", "4-1")
        score = data.get("score", 0)

        stat = stat_map.get(uid, {})
        wins = stat.get("wins", 0)
        losses = stat.get("losses", 0)
        total = wins + losses
        winrate = (wins / total * 100) if total > 0 else 0.0

        lines.append(f"{i}. {tier} | {score:+} ‚Äî {username} üèÜ{wins} / üíÄ{losses} ‚Äî {winrate:.1f}%")

    await interaction.followup.send("\n".join(lines))

@bot.tree.command(name="match_history", description="–°“Ø“Ø–ª–∏–π–Ω 5 match-–∏–π–Ω –º—ç–¥—ç—ç–ª—ç–ª (SQL —Ö—É–≤–∏–ª–±–∞—Ä)")
async def match_history(interaction: discord.Interaction):
    try:
        await interaction.response.defer(thinking=True)
    except discord.errors.InteractionResponded:
        return

    try:
        conn = await connect()
        rows = await conn.fetch("""
            SELECT timestamp, mode, strategy, initiator_id, winners, losers
            FROM matches
            ORDER BY timestamp DESC
            LIMIT 5
        """)
        await conn.close()
    except Exception:
        import traceback
        traceback.print_exc()
        await interaction.followup.send("‚ùå Match —É–Ω—à–∏—Ö “Ø–µ–¥ –∞–ª–¥–∞–∞ –≥–∞—Ä–ª–∞–∞.")
        return

    if not rows:
        await interaction.followup.send("üì≠ Match –±“Ø—Ä—Ç–≥—ç–ª —Ö–æ–æ—Å–æ–Ω –±–∞–π–Ω–∞.")
        return

    lines = ["üìú **–°“Ø“Ø–ª–∏–π–Ω Match-—É—É–¥:**"]

    import json
    from datetime import timezone, timedelta

    def ensure_list(x):
        if x is None:
            return []
        if isinstance(x, (list, tuple)):
            return list(x)
        if isinstance(x, str):
            try:
                v = json.loads(x)
                return v if isinstance(v, list) else []
            except Exception:
                return []
        return []

    for i, row in enumerate(rows, 1):
        ts = row["timestamp"]
        # tzinfo –±–∞–π—Ö–≥“Ø–π timestamp –∏—Ä–≤—ç–ª UTC –≥—ç–∂ “Ø–∑—ç–∂ –æ–Ω–æ–æ–Ω–æ
        try:
            if ts.tzinfo is None:
                ts = ts.replace(tzinfo=timezone.utc)
        except Exception:
            # –•–æ–≤–æ—Ä —Ç–æ—Ö–∏–æ–ª–¥–æ–ª–¥ ts –Ω—å datetime –±–∏—à –±–∞–π–≤–∞–ª –∞–ª–≥–∞—Å–Ω–∞
            pass

        try:
            dt = ts.astimezone(timezone(timedelta(hours=8)))
            ts_str = dt.strftime("%Y-%m-%d %H:%M")
        except Exception:
            ts_str = str(ts)

        mode = (row["mode"] or "").upper()
        strategy = row["strategy"] or "?"
        initiator = f"<@{row['initiator_id']}>"

        winners = ensure_list(row["winners"])
        losers = ensure_list(row["losers"])

        win_str = ", ".join(f"<@{uid}>" for uid in winners) if winners else "‚Äî"
        lose_str = ", ".join(f"<@{uid}>" for uid in losers) if losers else "‚Äî"

        lines.append(
            f"\n**#{i} | {mode} | üß† `{strategy}` | üïì {ts_str}** ‚Äî {initiator}\n"
            f"üèÜ Winner: {win_str}\n"
            f"üíÄ Loser: {lose_str}"
        )

    await interaction.followup.send("\n".join(lines))

@bot.tree.command(name="resync", description="Slash –∫–æ–º–∞–Ω–¥—É—É–¥—ã–≥ –¥–∞—Ö–∏–Ω –±“Ø—Ä—Ç–≥—ç–Ω—ç (–∞–¥–º–∏–Ω)")
async def resync(interaction: discord.Interaction):
    try:
        await interaction.response.defer(thinking=True)
    except discord.errors.InteractionResponded:
        return

    if not interaction.user.guild_permissions.administrator:
        await interaction.followup.send("‚õîÔ∏è –ó”©–≤—Ö”©–Ω –∞–¥–º–∏–Ω –∞—à–∏–≥–ª–∞–Ω–∞.", ephemeral=True)
        return

    try:
        synced = await bot.tree.sync(guild=interaction.guild)
        await interaction.followup.send(f"‚úÖ {len(synced)} –∫–æ–º–∞–Ω–¥ –∞–º–∂–∏–ª—Ç—Ç–∞–π –¥–∞—Ö–∏–Ω –±“Ø—Ä—Ç–≥—ç–≥–¥–ª—ç—ç.", ephemeral=True)
    except Exception as e:
        print("‚ùå resync –∞–ª–¥–∞–∞:", e)
        await interaction.followup.send("‚ö†Ô∏è –ö–æ–º–º–∞–Ω–¥ sync —Ö–∏–π—Ö “Ø–µ–¥ –∞–ª–¥–∞–∞ –≥–∞—Ä–ª–∞–∞.", ephemeral=True)

@bot.tree.command(name="diag", description="–ê–¥–º–∏–Ω: –æ—Ä—á–Ω—ã –æ–Ω–æ—à")
async def diag(interaction: discord.Interaction):
    if not interaction.user.guild_permissions.administrator:
        await interaction.response.send_message("‚õîÔ∏è –ó”©–≤—Ö”©–Ω –∞–¥–º–∏–Ω.", ephemeral=True); return
    try:
        await interaction.response.defer(ephemeral=True)
    except discord.errors.InteractionResponded:
        return

    # DB
    db_ok, db_msg = False, ""
    try:
        conn = await connect()
        await conn.execute("SELECT 1")
        await conn.close()
        db_ok, db_msg = True, "DB OK"
    except Exception as e:
        db_msg = f"DB FAIL: {e}"

    # OpenAI (–∂–∏–∂–∏–≥ JSON test)
    ai_ok, ai_msg = False, ""
    try:
        import json
        from openai import OpenAI
        client = OpenAI()
        r = await client.chat.completions.create(
            model="gpt-4o",
            messages=[{"role":"user","content":"Return {\"ok\":true} as JSON only"}],
            temperature=0,
            response_format={"type":"json_object"},
            max_tokens=16,
        )
        _ = json.loads(r.choices[0].message.content)
        ai_ok, ai_msg = True, "OpenAI OK"
    except Exception as e:
        ai_msg = f"OpenAI FAIL: {e}"

    # Perms (nickname edit)
    me = interaction.guild.me
    perm_ok = interaction.guild.me.guild_permissions.manage_nicknames
    perm_msg = "Nick perm OK" if perm_ok else "Nick perm MISSING"

    await interaction.followup.send(
        f"ü©∫ DIAG\n‚Ä¢ {db_msg}\n‚Ä¢ {ai_msg}\n‚Ä¢ {perm_msg}",
        ephemeral=True
    )

@bot.tree.command(name="diag_dryrun", description="–ê–¥–º–∏–Ω: DRY-RUN –æ–Ω–æ—à–∏–ª–≥–æ–æ (—è–º–∞—Ä —á ”©–≥”©–≥–¥”©–ª —Ö–∞–¥–≥–∞–ª–∞—Ö–≥“Ø–π)")
@app_commands.describe(
    mode='–ë–∞–ª–∞–Ω—Å—ã–Ω —Ç–µ—Å—Ç: "mock" (–∞–Ω—Ö–¥–∞–≥—á) —ç—Å–≤—ç–ª "real" (GPT –¥—É—É–¥–Ω–∞, —Ö–∞–¥–≥–∞–ª–∂ “Ø–ª–¥—ç—ç—Ö–≥“Ø–π)'
)
async def diag_dryrun(interaction: discord.Interaction, mode: str = "mock"):
    # 1) –∑”©–≤—à”©”©—Ä”©–ª
    if not interaction.user.guild_permissions.administrator:
        await interaction.response.send_message("‚õîÔ∏è –ó”©–≤—Ö”©–Ω –∞–¥–º–∏–Ω.", ephemeral=True)
        return
    try:
        await interaction.response.defer(ephemeral=True)
    except discord.errors.InteractionResponded:
        return

    messages = []

    # 2) DB DRY-RUN ‚Äî TEMP TABLE –∞—à–∏–≥–ª–∞–¥–∞–≥ —Ç—É–ª —è–º–∞—Ä —á —É–ª –º”©—Ä “Ø–ª–¥—ç—Ö–≥“Ø–π
    db_ok, db_msg = False, ""
    try:
        from database import connect
        conn = await connect()  # asyncpg.connect(DATABASE_URL) –∞—à–∏–≥–ª–∞–¥–∞–≥:contentReference[oaicite:1]{index=1}
        try:
            async with conn.transaction():
                await conn.execute("CREATE TEMP TABLE z_diag(x int);")
                await conn.execute("INSERT INTO z_diag(x) VALUES (1),(2),(3);")
                cnt = await conn.fetchval("SELECT COUNT(*) FROM z_diag;")
                db_ok = (cnt == 3)
            # TEMP TABLE –Ω—å transaction-–æ–æ—Å —Ö–∞–º–∞–∞—Ä–∞–ª–≥“Ø–π–≥—ç—ç—Ä —Å–µ—à–Ω –¥—É—É—Å–º–∞–≥—Ü —É—Å—Ç–Ω–∞
            db_msg = "DB OK (temp write/read –∞–∂–∏–ª–ª–∞–ª–∞–∞)" if db_ok else "DB WARN (unexpected count)"
        finally:
            await conn.close()
    except Exception as e:
        db_msg = f"DB FAIL: {e}"
    messages.append(f"‚Ä¢ {db_msg}")

    # 3) OpenAI DRY-RUN ‚Äî –∂–∏–∂–∏–≥ JSON —Ç–µ—Å—Ç
    ai_ok, ai_msg = False, ""
    try:
        from openai import OpenAI
        client = OpenAI()
        resp = await client.chat.completions.create(
            model="gpt-4o",
            messages=[{"role": "user", "content": "Return {\"ok\":true} as JSON only"}],
            temperature=0,
            max_tokens=16,
            # –•—ç—Ä–≤—ç—ç —Ç–∞–Ω–∞–π –æ—Ä—á–∏–Ω–¥ response_format –¥—ç–º–∂–∏—Ö–≥“Ø–π –±–æ–ª try/except-–æ–æ—Ä —É–Ω—Ç—Ä–∞–∞–∂ –±–æ–ª–Ω–æ
            response_format={"type": "json_object"},
        )
        _ = json.loads(resp.choices[0].message.content)
        ai_ok, ai_msg = True, "OpenAI OK"
    except Exception as e:
        ai_msg = f"OpenAI FAIL: {e}"
    messages.append(f"‚Ä¢ {ai_msg}")

    # 4) Discord permission ‚Äî nickname edit
    me = interaction.guild.me
    can_nick = bool(me.guild_permissions.manage_nicknames)
    perm_msg = "Nick perm OK" if can_nick else "Nick perm MISSING"
    messages.append(f"‚Ä¢ {perm_msg}")

    # 5) –ë–∞–ª–∞–Ω—Å—ã–Ω DRY‚ÄëRUN (—Ö—É—É–¥—É—É–Ω GPT MOCK —ç—Å–≤—ç–ª –±–æ–¥–∏—Ç–æ–æ—Ä GPT –¥—É—É–¥–∞–∞–¥ —Ö–∞–¥–≥–∞–ª–∞–ª–≥“Ø–π —Ö–∞—Ä—É—É–ª–Ω–∞)
    try:
        # –ñ–∏–Ω “Ø“Ø—Å–≥—ç—Ö: 10 —Ç–æ–≥–ª–æ–≥—á, 2 –±–∞–≥ * 5 —Ö“Ø–Ω
        team_count, players_per_team = 2, 5
        fake_players = [{"id": 10_000 + i, "power": random.randint(20, 120)} for i in range(team_count*players_per_team)]
        weights = {p["id"]: p["power"] for p in fake_players}

        if mode.lower() == "real":
            # –±–æ–¥–∏—Ç–æ–æ—Ä GPT-—ç—ç—Å –±–∞–≥ –∞–≤–Ω–∞ (teams), –ì–≠–•–î–≠–≠ —Ö–∞–¥–≥–∞–ª–∞—Ö–≥“Ø–π
            teams = await call_gpt_balance_api(team_count, players_per_team, fake_players)  # —Ç–∞–Ω—ã –æ–¥–æ–æ–≥–∏–π–Ω —Ñ—É–Ω–∫—Ü:contentReference[oaicite:2]{index=2}
            # –ª–æ–∫–∞–ª —Å–∞–π–∂—Ä—É—É–ª–∞–ª—Ç (swap) ‚Äî –∏–ª“Ø“Ø —Å–∞–π–Ω –±–∞–ª–∞–Ω—Å
            teams, cost = local_refine(teams, weights, max_rounds=100)  # —Ç–∞–Ω—ã —Ñ—É–Ω–∫—Ü:contentReference[oaicite:3]{index=3}
            mode_note = f"gpt+local_refine (diff={max(sum(weights.get(u,0) for u in t) for t in teams) - min(sum(weights.get(u,0) for u in t) for t in teams)})"
        else:
            # MOCK: greedy —ç—Å–≤—ç–ª reflector –∞—à–∏–≥–ª–∞–∂ —Ç“Ø—Ä —Ö”©—Ä–≤“Ø“Ø–ª—ç—ç–¥ (–∫–æ–¥–æ–¥ —á–∏–Ω—å –±–∏–π):contentReference[oaicite:4]{index=4}
            teams = greedy_teams(weights, team_count, players_per_team)
            teams, cost = local_refine(teams, weights, max_rounds=100)
            mode_note = f"mock+local_refine (diff={cost})"

        # –•–∞—Ä–∏—É–≥ –∑”©–≤—Ö”©–Ω —à–∞–ª–≥–∞—Ö –∑–æ—Ä–∏–ª–≥–æ–æ—Ä —Ö–∞—Ä—É—É–ª–Ω–∞ ‚Äî DB/session –¢–û–û–†–•–û–ô–õ–¢ –•–ò–ô–•–ì“Æ–ô
        totals = [sum(weights.get(uid,0) for uid in t) for t in teams]
        lines = [f"üß™ Balance DRY‚ÄëRUN ‚Äî {mode_note}",
                 f"Totals: {totals} (min={min(totals)}, max={max(totals)})"]
        for i, t in enumerate(teams, 1):
            lines.append(f"#{i} ‚Üí " + ", ".join(f"{uid}:{weights[uid]}" for uid in t))
        messages.append("\n".join(lines))
    except Exception as e:
        messages.append(f"‚Ä¢ Balance DRY‚ÄëRUN FAIL: {e}")

    # 6) –≠—Ü—Å–∏–π–Ω —Ç–∞–π–ª–∞–Ω (—ç–øhemeral)
    await interaction.followup.send("ü©∫ **DRY‚ÄëRUN DIAG**\n" + "\n".join(messages), ephemeral=True)

# üéØ Run
async def main():
    from keep_alive import keep_alive
    keep_alive()  # üü¢ Railway –¥—ç—ç—Ä –∞–º—å–¥ –±–∞–π–ª–≥–∞—Ö —Å–µ—Ä–≤–µ—Ä

    if not TOKEN:
        print("‚ùå DISCORD_TOKEN —Ç–æ—Ö–∏—Ä—É—É–ª–∞–≥–¥–∞–∞–≥“Ø–π –±–∞–π–Ω–∞.")
        return

    print("üöÄ Bot —ç—Ö–ª—ç—Ö –≥—ç–∂ –±–∞–π–Ω–∞...")
    await bot.start(TOKEN)

if __name__ == "__main__":
    import asyncio
    asyncio.run(main())

